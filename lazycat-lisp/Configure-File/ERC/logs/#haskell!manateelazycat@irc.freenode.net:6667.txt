
[‘ËÄ 12‘ÔÂ  4 2008]
*** Topic for #haskell: ["Real World Haskell: it is alive!", "The Haskell
    programming language", "http://haskell.org", "Paste: http://hpaste.org",
    "Logs: http://tunes.org/~nef/logs/haskell/"]  [03:40:35]
*** #haskell: topic set by dons, 10:49:38 2008/11/26
*** Users on #haskell: ManateeLazyCat ikaros netx Lor ikaros_ Lamperi
    Dynetrekk_ eu-prleu-peupeu novas0x2a tttm olsner araujo seafood iZZy` igel
    Trinithis amiddelk yaxu mrsolo gabor andyjgill astrolabe geezusfreeek
    athos gbacon d2dchat mwhitney zeno erikc zachk neun QplQyer markluffel
    Lemmih dje_ ToRA|MSR_ saccade Deeem2031 mlesniak polymar loriel jsn zoq
    Pellwurst tomh madnificent bos mm_freak Trafalgard skorpan mikezackles
    paolino Twey sebaseba vixey arw willb 
*** Users on #haskell: mriou mattrepl lerkok satchiii AtnNn pao roderyk proq
    smg lambdabot sam_ hallongrottan SyntaxRebel_ perspectival1 linuxmain
    andrewsw marko1 omy andun AnalogHole klugez arjanoosting opqdonut fnordus
    Zao Blub\0 Jaak matveev polux liesen jimki shepheb Botje czShadoW methos
    cjs fanf enolan ned yango MrDomino_ Eridius papermachine RayNbow BONUS_
    Debolaz EmielRegis manicman tst__ gbeshers kayess arjanb jpcooper
    JaffaCake Nshag stephens rdd nominolo|msr 
*** Users on #haskell: tibbe kazimir lefant pizza_ pierre- alex23 sw17ch BMeph
    Guest90792 GNU\caus11c faluf whoppix noZone1 hkBst joelpet mortenlysgaard
    dejones spoop Igloo purple__ mapreduce cnwdup lurkymclurkleton jeremiah
    falseep trie kaol neurogeek||m path[l] dmwit_ aik ChilliX iggly_ Valodim
    OnionKnight iblechbot snhmib gander AshyIsMe Snark Itkovian takinitez
    bens__ clanehin Baughn dort hrehf saiam wchogg zax Daniel_H dolio Athas
    trofi coldhak Spockz pcapriotti 
*** Users on #haskell: ksf Bleadof jberg QtPlatyp1s shintah aeolist Liskni_si
    therp ulfdoz nornagon agentzh al-maisan twanvl Beelsebob nominolo_ Dessous
    pumpkin_ xinming_ drbean Saul solrize Lemonator Philonous1 tarbo z|Andy
    Korollary kryptiskt tredontho equanimi1y authentic Armored_Azrael Saizan
    JuanDaugherty Axioplase alexsuraci leimy loop gwern xd kpreid u_quark SamB
    Axman6 docmach maek roconnor borism tessier kynky mikv Jedai fredcy ArneB
    gpolo cladhaire 
*** Users on #haskell: xcthulhu_ DuClare gnufied eno jaj PsiOmega welterde te
    aartist sereven kolmodin scook0 jeffersonheard dfeuer nathanic dblazakis
    ttmrichter_ amiri Riastradh Twigathy EvilTerran Guest4981383 qz jajamana1
    sjanssen BfrOv3rfl0w dmead score cpfr Plareplane dufflebu1k Mr_Awesome
    gmaslov Cale mlh ushdf helgim SamB_XP lament bjorkLinux jfredett keseldude
    oklopol thetallgu1 mrd Deewiant luite_ snigel_ netcat r3m0t_ funktio
    fophillips cognominal kpk 
*** Users on #haskell: sbahra sebbe1991 pchiusano leadnose djjack telexicon
    ystael kar-1 Taggnostr wolgo_ tylere zipMe hukolele mightybyte Ezla
    yahooooo rangaparma mopped_ ajhager thetallguy British0zzy shachaf
    mjrosenb raxas cjb Khisanth bohanlon thingwath Shimei jimt Shurique maskd
    m90 dvekravy DarthShrine Aisling randomit1 hackage sbahra[] jan__
    pauleeallen52 Cthulhon cinimod m4thrick birkenfeld tltstc lucca mux
    mercury^ djinni pythonist kennyv lanaer tchakkazulu 
*** Users on #haskell: Megant pshc davidL preflex jelmer SimonRC sutats
    Philippa gogonkt_ shapr nnunley smtms eyck atsampson Tigge Gabbie Soliah
    solrize_ lasts ehird webframp mml` pixel_ sclv olahol Raevel trez p_l
    wagle glguy mfp _MaK_ Ferdirand cjay poliquin bd_ stalker_ jonafan Elly
    aleator edwinb matthew-_ karld allbery_b pragma_ nothingmuch baaba glith
    earthy PHO_ @ChanServ rog def__ im_maciek anders^^ slarba_ bynari syscrash
    loupgaroublond StoneToad liff 
*** Users on #haskell: dancor Tomas Modius taari frederik SubStack wolverian
    xHemi TML noj Badger lunabot nwf byorgey Poeir tromp liyang pengrate ibid
    c9s kosmikus DrSyzygy Skyp markovChain nasloc__ quicksilver viklund emma
    fadec blazzy maxote DarthMeh osfameron DustyDingo nemik juhp jml iratsu
    Nanar vegai Eelis fabjan boyscared levitation[A] mattam erg heavensrevenge
    xian m_stone daf dcoutts Wechner Japsu newt0n ksandstr kalven ahf
    mgregsond bmc_ mauke flori 
*** Users on #haskell: Apocalisp orbitz quuxman newsham felipe Nafai ziman
    agemo dionoea hesselink marmolak Giraffe wjt flux obraun wormcc stylus
    jmob cods Mitar sad0ur gdsx vincenz idnar MyCatVerbs tmoertel_away tote
    r0bby Laney Funjker_Boy22 ivan koninkje_away TOLUanckA lilac regulate
    ski__ grul explicitjelly Vq^ jql And[y] Sartak DRMacIver mokus bockmabe
    Vulpyne Somni lispy inimino tmielika Draconx Choko dublpaws holzplatten
    admodum issal suiside Caelum thedward 
*** Users on #haskell: Jiten stevan tvaal chrisdone dons Pistahh C-Keen faXx
    sbok dcoutts_ shrimpx Anthraxx miasma kokekola bran_ pcc1 tuukkah Spark
    laz0r clog twifkak Arnar desp znutar_ integral ertai xmux qebab grantrules
    rey_ nybyn rodge Ornedan IsoPallo_ MarcWeber Stephan202 gds mornfall ski_
    decklin thorkilnaur Hunner malouin shawn__ chr1s joed hellige 
*** #haskell URL: http://www.haskell.org/  [03:40:36]
<thetallgu1> Is there a generics chat room?  [03:40:57]
*** #haskell modes: +tncL  [03:41:00]
*** #haskell was created on ‘ÐÇ‘ÆÚ‘ÈÕ 2006/11/26 14‘Ê±42‘·Ö48‘Ãë
<gwern> you think there are so many people who want to discuss generics?
                                                                     [03:41:38]
<thetallgu1> gwern: no, but perhaps they've been growing like mushrooms,
             quietly and out of sight?  [03:42:16]
<mercury^> vixey: how do you mean?  [03:42:42]
<gwern> thetallgu1: sunlight is the best disinfectant for that  [03:42:48]

[‘ËÄ 12‘ÔÂ  4 2008]
*** Topic for #haskell: ["Real World Haskell: it is alive!", "The Haskell
    programming language", "http://haskell.org", "Paste: http://hpaste.org",
    "Logs: http://tunes.org/~nef/logs/haskell/"]  [03:43:47]
*** #haskell: topic set by dons, 10:49:38 2008/11/26
*** Users on #haskell: ManateeLazyCat Corun pjdelport jmo- ikaros netx Lor
    ikaros_ Lamperi eu-prleu-peupeu novas0x2a tttm olsner araujo seafood iZZy`
    igel Trinithis amiddelk yaxu mrsolo gabor andyjgill astrolabe geezusfreeek
    athos gbacon d2dchat mwhitney zeno erikc zachk neun QplQyer markluffel
    Lemmih dje_ ToRA|MSR_ saccade Deeem2031 mlesniak polymar loriel jsn zoq
    Pellwurst tomh madnificent bos mm_freak Trafalgard skorpan mikezackles
    paolino Twey sebaseba vixey 
*** Users on #haskell: arw willb mriou mattrepl lerkok satchiii AtnNn pao
    roderyk proq smg lambdabot sam_ hallongrottan SyntaxRebel_ perspectival1
    linuxmain andrewsw marko1 omy andun AnalogHole klugez arjanoosting
    opqdonut fnordus Zao Blub\0 Jaak matveev polux liesen jimki shepheb Botje
    czShadoW methos cjs fanf enolan ned yango MrDomino_ Eridius papermachine
    RayNbow BONUS_ Debolaz EmielRegis manicman tst__ gbeshers kayess arjanb
    jpcooper JaffaCake Nshag stephens 
*** Users on #haskell: rdd nominolo|msr tibbe kazimir lefant pizza_ pierre-
    alex23 sw17ch BMeph Guest90792 GNU\caus11c faluf whoppix noZone1 hkBst
    joelpet mortenlysgaard dejones spoop Igloo purple__ mapreduce cnwdup
    lurkymclurkleton jeremiah falseep trie kaol neurogeek||m path[l] dmwit_
    aik ChilliX iggly_ Valodim OnionKnight iblechbot snhmib gander AshyIsMe
    Snark Itkovian takinitez bens__ clanehin Baughn dort hrehf saiam wchogg
    zax Daniel_H dolio Athas trofi coldhak 
*** Users on #haskell: Spockz pcapriotti ksf Bleadof jberg QtPlatyp1s shintah
    aeolist Liskni_si therp ulfdoz nornagon agentzh al-maisan twanvl Beelsebob
    nominolo_ Dessous pumpkin_ xinming_ drbean Saul solrize Lemonator
    Philonous1 tarbo z|Andy Korollary kryptiskt tredontho equanimi1y authentic
    Armored_Azrael Saizan JuanDaugherty Axioplase alexsuraci leimy loop gwern
    xd kpreid u_quark SamB Axman6 docmach maek roconnor borism tessier kynky
    mikv Jedai fredcy ArneB gpolo 
*** Users on #haskell: cladhaire xcthulhu_ DuClare gnufied eno jaj PsiOmega
    welterde te aartist sereven kolmodin scook0 jeffersonheard dfeuer nathanic
    dblazakis ttmrichter_ amiri Riastradh Twigathy EvilTerran Guest4981383 qz
    jajamana1 sjanssen BfrOv3rfl0w dmead score cpfr Plareplane dufflebu1k
    Mr_Awesome gmaslov Cale mlh ushdf helgim SamB_XP lament bjorkLinux
    jfredett keseldude oklopol thetallgu1 mrd Deewiant luite_ snigel_ netcat
    r3m0t_ funktio fophillips cognominal 
*** Users on #haskell: kpk sbahra sebbe1991 pchiusano leadnose djjack
    telexicon ystael kar-1 Taggnostr wolgo_ tylere zipMe hukolele mightybyte
    Ezla yahooooo rangaparma mopped_ ajhager thetallguy British0zzy shachaf
    mjrosenb raxas cjb Khisanth bohanlon thingwath bran_ pcc1 tuukkah Spark
    laz0r clog twifkak Arnar desp znutar_ integral ertai xmux qebab grantrules
    rey_ nybyn rodge Ornedan IsoPallo_ MarcWeber Stephan202 gds mornfall ski_
    decklin thorkilnaur Hunner malouin 
*** Users on #haskell: shawn__ chr1s joed hellige kokekola miasma Anthraxx
    shrimpx dcoutts_ sbok faXx C-Keen Pistahh dons chrisdone tvaal stevan
    Jiten thedward Caelum suiside issal admodum holzplatten dublpaws Choko
    Draconx tmielika inimino lispy Somni Vulpyne bockmabe mokus DRMacIver
    Sartak And[y] jql Vq^ explicitjelly grul ski__ regulate lilac TOLUanckA
    koninkje_away ivan Funjker_Boy22 Laney r0bby tote tmoertel_away MyCatVerbs
    idnar vincenz gdsx sad0ur Mitar cods 
*** Users on #haskell: jmob stylus wormcc obraun flux wjt Giraffe marmolak
    hesselink dionoea agemo ziman Nafai felipe newsham quuxman orbitz
    Apocalisp flori mauke bmc_ mgregsond ahf kalven ksandstr newt0n Japsu
    Wechner dcoutts daf m_stone xian heavensrevenge erg mattam levitation[A]
    boyscared fabjan Eelis vegai Nanar iratsu jml juhp nemik DustyDingo
    osfameron DarthMeh maxote blazzy fadec emma viklund quicksilver nasloc__
    markovChain Skyp DrSyzygy kosmikus c9s ibid 
*** Users on #haskell: pengrate liyang tromp Poeir byorgey nwf lunabot Badger
    noj TML xHemi wolverian SubStack frederik taari Modius Tomas dancor liff
    StoneToad loupgaroublond syscrash bynari slarba_ anders^^ im_maciek def__
    rog PHO_ earthy glith baaba nothingmuch pragma_ allbery_b karld matthew-_
    edwinb aleator Elly jonafan stalker_ bd_ poliquin cjay Ferdirand _MaK_ mfp
    glguy wagle p_l trez Raevel olahol sclv pixel_ mml` webframp ehird lasts
    solrize_ Soliah Gabbie 
*** Users on #haskell: Tigge atsampson eyck smtms nnunley shapr gogonkt_
    Philippa sutats SimonRC jelmer preflex davidL pshc Megant tchakkazulu
    lanaer kennyv pythonist djinni mercury^ mux lucca tltstc birkenfeld
    m4thrick cinimod Cthulhon pauleeallen52 jan__ sbahra[] hackage randomit1
    Aisling DarthShrine dvekravy m90 maskd Shurique jimt Shimei @ChanServ 
*** #haskell URL: http://www.haskell.org/  [03:43:48]
*** #haskell modes: +tncL  [03:44:10]
*** #haskell was created on ‘ÐÇ‘ÆÚ‘ÈÕ 2006/11/26 14‘Ê±42‘·Ö48‘Ãë
<thetallgu1> gwern: I think the generics workshop should put your name on a
             security list  [03:44:27]
<gwern> thetallgu1: I can't help it. my whole family is made of meat.
                                                                     [03:44:51]
<thetallgu1> gwern: boneless?  [03:45:17]
* gwern also notes that this isn't my meatspace name, so they can ban gwern
  all they want  [03:45:18]
<gwern> thetallgu1: no, they come with shells and intestines I have to
        remove. they're a lot like shrimp.  [03:46:21]
<gwern> big shrimp  [03:46:25]
<ksf> @remember bucky Each lobe of a baseball is simply a precessed triangle
      of a tetrahedron. The baseball is yin-yang, not in a plane but in
      Universe: it is telling us that complementarities interprecess
      omnidirectionally and not just in a plane, as the planar yin-yang
      suggests.  [03:46:28]
<lambdabot> It is stored.  [03:46:29]
<ksf> scnr.  [03:46:31]
<glguy>  diff <(git show master:Setup.hs) <(git show
        origin/master:cdrss-db-backend.cabal)  [03:46:48]
<glguy> err  [03:46:55]
<gwern> @quote lobe  [03:47:10]
<lambdabot> bucky says: Each lobe of a baseball is simply a precessed triangle
            of a tetrahedron. The baseball is yin-yang, not in a plane but in
            Universe: it is telling us that complementarities interprecess
                                                                     [03:47:11]
<lambdabot> omnidirectionally and not just in a plane, as the planar yin-yang
            suggests.
<gwern> bucky could be hard to understad, especially when he got onto geometry
                                                                     [03:47:30]
<ksf> yeah.  [03:47:53]
<ksf> i'm scanning synergetics to find out whether or not he has anything to
      say about 4 tetrahedrons making up a cube or 6.  [03:48:24]
<gwern> how could 4 tetrahedrons make a cube?  [03:49:25]
<ksf> lining up d4's its suggestive, at least if you take skewing into
      account.  [03:49:56]
<jkramar> anyone know how to color a Geometry2 in reactive-fieldtrip? colors
          seem to be useful only to create materials, which only modify
          Geometry3s, but flatG::Geometry2->Geometry3 doesn't seem to solve
          the problem  [03:50:25]
<ksf> anyway, the tao symbol represents a third and fourth dimension by
      inclusion of one-into-the-other.  [03:50:35]
<sbahra> newsham == Timothy Newsham?  [03:51:18]
<ksf> I need squeezable d4 or a better imagination.  [03:51:50]
<jkramar> sorry, I didn't really mean reactive-fieldtrip, just fieldtrip.
                                                                     [03:52:08]
<ksf> sor I could try to cut one of those d6's.  [03:52:19]
<sbahra> Yes  [03:52:46]
<Cale> jkramar: Can't you apply a colour to the resulting Geometry3?
                                                                     [03:52:59]
<ehird> I've forgotten, how do data and newtype diffe?  [03:53:03]
<ehird> differ  [03:53:05]
<jkramar> wait, 4 tetrahedrons whose union is a cube? doesn't sound nice
                                                                     [03:53:24]
<gwern> newtype takes constructors with one argument  [03:53:28]
<gwern> and gets compiled away  [03:53:32]
<gwern> data doesn't, and takes more. iirc  [03:53:38]
<sbahra> ehird, newtype incurs no compile-time overhead.  [03:53:46]
<sbahra> gwern, it can take 1.  [03:53:49]
<vixey> does GHC promise that?  [03:53:53]
<sbahra> But you can have multiple constructors.  [03:53:57]
<ehird> ah yes, only one argument  [03:54:00]
<sbahra> err  [03:54:01]
<sbahra> vixey, I meant, run-time overhead.  [03:54:06]
<ksf> well i know that 6 work, but i can't get 4 out of my head.  [03:55:48]
<newsham> sbahra: yes  [03:56:58]
<eu-prleu-peupeu>
                 http://www.ddj.com/development-tools/212201710;jsessionid=Z2EE14U5SJ5HMQSNDLOSKH0CJUNN2JVN?pgno=2
                                                                     [03:57:11]
<eu-prleu-peupeu> ehhh  [03:57:12]
<lambdabot> Title: Dr. Dobb's | It's Time to Get Good at Functional
            Programming | December 3, 2008, http://tinyurl.com/6cqjqe
                                                                     [03:57:17]
<eu-prleu-peupeu> how can someone write this on 2008 ? :/  [03:57:23]
<eu-prleu-peupeu> about haskell, i mean  [03:57:28]
<gwern> eu-prleu-peupeu: it's Dr. Dobb's. they go into orgasms over java and
        c++  [03:57:42]
<gwern> we should be happy they didn't say something like 'an interesting
        research language, but no industrial-strength implementations'
                                                                     [03:58:49]
<eu-prleu-peupeu> "It presently has no commercial implementations."  [03:59:11]
<gwern> although that comment about commercial implementations comes closes
        did I mentioned dr. dobbs is institutionally biased in favor of
        commercial stuff?  [03:59:13]
<naradapuri> \h set color  [03:59:18]
<eu-prleu-peupeu> i see :/  [03:59:24]
<eu-prleu-peupeu> closed minds  [03:59:28]
<gwern> actually, I wouldn't've been surprised at a comment like 'Haskell has
        weak support for Microsoft Windows, and so is useless' :)  [03:59:56]
<ksf> @remember bucky Energy is finite. Physical Universe is finite. Physical
      Universe is just as finite as the triangle of 180 degrees.  [04:00:10]
<lambdabot> I will never forget.
<erikc> is there a monad that is the inverse of the maybe monad (returns the
        first Just value)  [04:00:31]
<eu-prleu-peupeu> i follow the feed on multicoreinfo.com
<centrinia> Is the universe really finite?  [04:00:41]
<eu-prleu-peupeu> no haskell articles ever appear, and when one does, it comes
                 out like this :/  [04:00:42]
<vixey> I don't think that's possible erikc  [04:00:52]
<vixey> wouldn't that be a type error  [04:00:57]
<gwern> centrinia: well, infinite universes involve you in problems  [04:01:01]
<vixey> :t (>>=)  [04:01:02]
<lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
                                                                     [04:01:04]
<gwern> ie. how do we see a dark night sky if the universe is infinite?
                                                                     [04:01:20]
<vixey> There's the Either a Monadi which always returns the first  Left A if
        there was one  [04:01:21]
<gwern> and let's not even get into issues like 'how is science (and induction
        in general) even possible in an infinite universe?'  [04:01:53]
<vixey> gwern, light gets sucked round corners  [04:01:55]
<Saizan> erikc: there's the First monoid  [04:02:19]
<centrinia> It takes longer for very distant light to come here. :)  [04:02:29]
<gwern> centrinia: but the light has had all eternity to get here  [04:02:52]
<vixey> @hoogle First  [04:03:43]
<lambdabot> Data.Monoid newtype First a
<lambdabot> Data.Monoid First :: Maybe a -> First a  [04:03:44]
<lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
<lament> gwern: why eternity?  [04:04:13]
<lament> gwern: or does the universe have to be infinite in time as well as
         space?  [04:04:26]
<gwern> lament: you want to suggest an infinite universe was created a finite
        time ago?  [04:04:34]
<lament> gwern: sure  [04:04:39]
<lament> poof, just like that  [04:04:43]
<lament> six thousand years aog  [04:04:51]
<lament> ago  [04:04:53]
<centrinia> This isn't correct: "Monads are one such trick: Impure functions
            that have side effects and that can call pure FP functions but
            can't be called by them."  [04:04:57]
<lament> it's a good layman description of the most salient thing about monads
                                                                     [04:05:22]
<gwern> lament: in a sense, space and time are interchangeable, so if you have
        infinite time, you might as well have infinite space and vice versa
                                                                     [04:05:52]
<Saizan> except "side effects" means something different for every monad
                                                                     [04:06:11]
<gwern> but the real killer for infinite spatial universes is the quantum foam
                                                                     [04:06:18]
<lament> gwern: not if we assume an infinite universe that was created
         finitely long ago, then they're not  [04:06:19]
<sbahra> eu-prleu-peupeu, yeah :-/  [04:06:36]
<sbahra> eu-prleu-peupeu, "You want a pure (not hybrid) FP experience and you
         aren't expecting to get productive work out of the exploration. Is
         there a best language for simply learning functional programming? A
         good case can be made for Haskell."  [04:06:38]
<pizza_> depends on your definition of infinity  [04:06:41]
<sbahra> eu-prleu-peupeu, hehe
<vixey> infinity = 12  [04:06:58]
<gwern> since there's a non-zero change of the quantum foam spontaneously
        created a complex structure, in an infinite universe, there will be an
        infinite number of any given complex structure. this includes your
        brain.  [04:07:01]
<Corun> 13 = 12  [04:07:12]
<vixey> "this is your brain on quantum theory"  [04:07:24]
<gwern> and of course, as each brain dies horribly, it will observe different
        things from our earth-bound brains; given that we have no way to
        distinguish our earth-bound brains with a history from the infinitely
        many space-brains, we should logically expect each moment to begin
        hallucinating as we die; science should be impossible  [04:08:37]
<BMeph> gwern, lament: I thought space and time were inversely
        interchangeable? ;)  [04:08:56]
<gwern> BMeph: well, you get this anti-result regardless of whether you assume
        infinite time and finite space, or infinite space and finite time
                                                                     [04:09:27]
<ksf> dammit. now i got an algebraic proof in my head but still no visuals.
                                                                     [04:09:33]
<geezusfreeek> my latest shell alias: alias :wq='exit'  [04:10:12]
<ManateeLazyCat>   [04:10:23]
<gwern> BMeph: since in one, you have an infinite number of brains produced in
        a short time period, and in the other you have one small region
        producing an infinite number of brains over all eternity; the same
        result obtains - an infinite number of versions of you dying horribly
                                                                     [04:10:42]
<geezusfreeek> i did it enough by accident already  [04:10:45]
<mauke> I never use :wq  [04:10:48]
<mauke> it's always :q, :x or :xa  [04:10:55]
<centrinia> Why is gwern being so morbid? :)  [04:11:20]
<geezusfreeek> heh  [04:11:23]
<pizza_> :x being a more optimized version of :w?  [04:11:25]
<gwern> centrinia: infinite time is a morbid topic. look up Nietzsche's
        Eternal Recurrence for a good time  [04:11:53]
<centrinia> Okay.  [04:12:03]
<ksf> :x is wq iirc.  [04:12:09]
<ksf> @quote energy is finite  [04:13:15]
<lambdabot> No quotes for this person. :(
<ksf> @quote bucky  [04:13:20]
<lambdabot> bucky says: Energy is finite. Physical Universe is
            finite. Physical Universe is just as finite as the triangle of 180
            degrees.  [04:13:21]
<ksf> see?  [04:13:24]
<ksf> there's no infinity in the universe.  [04:13:33]
<erikc> First works perfectly  [04:13:58]
<erikc> getFirst $ mconcat $ map (First . (!?) (infoAttrs di)) [kDW_AT_name,
        kDW_AT_specification]  [04:14:03]
<jkramar> ksf: what are you proving?  [04:14:05]
<erikc> hottt
<ksf> that time is finite, but unending.  [04:14:17]
<ksf> but then, you might look up _that_ bucky quote for yourselves.
                                                                     [04:14:31]
<vixey> getFirst $ mconcat $ map (First . f) s ?  [04:14:37]
<jkramar> what does that even mean?  [04:14:41]
<vixey> can this be be similar to f . head ?  [04:14:50]
<vixey> @src First  [04:14:53]
<lambdabot> Source not found. I've seen penguins that can type better than
            that.  [04:14:54]
<vixey> :t First  [04:14:57]
<lambdabot> forall a. Maybe a -> First a  [04:14:59]
<vixey> ok I guess you need filter too, or listToMaybe  [04:15:15]
<erikc> vixey: the issue is i have a property bag which is Map Int Dynamic,
        and a variety of properties can correspond to the "name"  [04:15:35]
<ksf> in his view, the universe is the only existing perpetuum mobile, the
      only perfect equilibrium and some kind of y combinator.  [04:15:39]
<erikc> in a preferred order  [04:15:42]
<centrinia> @faq Can Haskell compute every possible state of an infinite
            universe?  [04:15:56]
<lambdabot> The answer is: Yes! Haskell can do that.
<vixey> ksf, time cube s  [04:15:59]
<erikc> (not my design, just how the DWARF file format is implemented)
                                                                     [04:16:16]
<wchogg> I think I've come in on the tail end of a rather odd meta-physics
         discussion.  [04:16:27]
*** zeno_ (n=andrew@97-112-134-206.clsp.qwest.net) is now known as zeno
                                                                     [04:17:21]
<gwern> wchogg: infinite universes make for very interesting discussions on
        identity and knowledge  [04:17:23]
<centrinia> Wow, ontology and epistemology.  [04:17:49]
<ksf> the problem with bucky is that most of the time you can't tell whether
      or not he's insane or you don't get his genie.  [04:18:51]
<wchogg> gwern:  I don't quite get the point.  It seems like you're using
         terms like quantum foam a bit loosely.  [04:19:41]
<centrinia> ksf: That is true of any genius/whacko. :)  [04:20:52]
<gwern> wchogg: no, I think it's a valid use  [04:21:02]
<blueonyx> ahoi  [04:22:50]
<wchogg> gwern:  I think I'm not being very clear, sorry.  I meant that it
         wasn't clear above what you mean mathematically by quantum foam.
                                                                     [04:23:02]
<ksf> @remember bucky The invention of the game of limited and terminal local
      awareness that we call "life" is in contradistinction to the concept of
      eternally total cosmic knowledge, intellect, and wisdom, whose totality
      of comprehensive comprehension would answeringly cancel out all
      questions and all problems, which would result in the eternally
      timeless, sublime 0=0 equation of absolute perfection.  [04:24:44]
<lambdabot> It is stored.
<gwern> wchogg: ok. the key assumption is that there is a non-zero
        possibility, at every time and at every point that something will be
        randomly created. we can go by volume, and say the 'something' is some
        aggregation of atoms; if we calculate out the unlikelihood of all the
        atoms in air clumping together to form me, we find that it is
        incredibly close to zero - but not zero. and thus, anything non-zero
        times infinity is infinitys  [04:25:13]
<ksf> gwern, you're not taking information into account.  [04:26:01]
<wchogg> gwern:  but things aren't just 'created' out of the vaccum.  Any
         particles are off mass shell and are thus virtual.  [04:26:03]
<ksf> it's got a gravity all of its own, see terry pratchett.  [04:26:24]
<gwern> wchogg: alright. then would you prefer we toss in another restriction,
        we only consider space around blackholes so we are working off hawking
        radiation? <begins the line of reasoning again>  [04:26:56]
<gwern> (you can toss in as many restrictions as you like; as long as the
        chance is still nonzero, we're in business)  [04:27:32]
<ksf> You cannot limit your analysis to any subpart of the general mishmash
      and still make sense.  [04:28:09]
<ksf> it won't work.  [04:28:12]
<FunctorSalad> :)  [04:28:41]
<centrinia> Don't you have to assume the Axiom of Choice to assert that any
            configuration of an infinite number of random events with nonzero
            probability will have a nonzero probability?  [04:29:51]
<gwern> centrinia: I'm not sure. I've thought it out and it seems that there
        are only so many distinct arrangements of matter because of planck and
        hubble limits  [04:30:56]
<geezusfreeek> centrinia, that doesn't sound right to me. even a single one of
               those events has nonzero probability. i don't have to even
               assume infinite  [04:31:02]
<ksf> Thou hast no Right but to do thy Will  [04:32:50]
* gwern goes and reads about the [[Poincar‘¨¦ recurrence theorem]]  [04:33:11]
<gwern> ('The Recurrence theorem apparently contradicts the Second law of
        thermodynamics, which says that large dynamical systems evolve
        irreversibly towards the state with higher entropy, so that if one
        starts with a low-entropy state, the system will never return to it.')
                                                                     [04:33:34]
<gwern> not quite applicable to our discussion, but interesting in a context
        of the Eternal Recurrence  [04:34:14]
<centrinia> Didn't someone refuse a Field's medal for proving that theorem?
<wchogg> No, that's something else.  [04:34:26]
<gwern> centrinia: no, I think that was Poinare's conjecture, not the theorem
                                                                     [04:34:40]
<gwern> if it doesn't have a proof, it's not much of a theorem :)  [04:34:50]
<Cale_> Which theorem?  [04:35:13]
*** Cale_ (n=Cale@CPE001c10c70239-CM000e5cdd834a.cpe.net.cable.rogers.com) is
    now known as Cale  [04:35:34]
<gwern> Cale: you'll never know! bwa ha ha  [04:35:44]
<Cale> I suppose I could go look at the logs :)  [04:36:06]
<FunctorSalad> maybe you need AC to even show the existence of a measure on
               teh infinite product space  [04:36:08]
* FunctorSalad is not teh sure  [04:36:14]
<Cale> On Hilbert's cube?  [04:36:42]
<FunctorSalad> no wait, I think that was for showing existence of
               non-measurable sets
<FunctorSalad> Cale: just a sequence of independent variables here, I'd think
                                                                     [04:37:09]
<FunctorSalad> (I was replying to what centrinia asked earlier)  [04:37:42]
<centrinia> If the cross product of nonempty sets is nonempty, then the Axiom
            of Choice is true. :)  [04:38:01]
<centrinia> *cartesian product.  [04:38:24]
<Cale> And not just a finite Cartesian product, but an arbitrary one :)
                                                                     [04:38:50]
<FunctorSalad> you don't need AC for making an element of {0,1}^Integers or so
               ;)  [04:39:27]
<centrinia> What about the cartesian product of {0,1} indexed by reals?
                                                                     [04:40:10]
<FunctorSalad> but for showing that not every set is measurable in the
               "product" sigma algebra or how it's called  [04:40:25]
<Cale> That's easy too.  [04:40:35]
<centrinia> What about indexing over the power set of the reals?  [04:40:52]
<Cale> You only really need the axiom of choice when there isn't a rule which
       you can use to specify an element.  [04:41:24]
<centrinia> Oh, so indexing over the set of all sets that are not members of
            themselves would be a problem?  [04:41:47]
<FunctorSalad> centrinia: "you don't need AC to choose a shoe from each pair
               of infinitely many pairs of shoes, but for pairs of socks you
               do" :)  [04:41:56]
<Cale> That's not a set.  [04:42:00]
<Cale> Right, for the shoes, you can just say always pick the left one.
                                                                     [04:42:30]
<centrinia> I don't need to invoke the Axiom of Choice when I can index over
            any set?  [04:43:09]
<Cale> I'm not sure what you mean by thats  [04:43:27]
<ksf> you can't choose without having a rule, the axiom of choice just
      conjures one up. it's paradoxical in itself.  [04:43:30]
<Cale> The axiom of choice isn't really paradoxical.  [04:43:43]
<vixey> choice is usually provable in specific case  [04:44:14]
<Cale> I'm pretty sure it's been shown that the consistency of ZFC is
       equivalent to the consistency of ZF.  [04:44:15]
<ksf> you can't even choose the axiom of choice from the set of all axioms
      without having a rule.  [04:44:18]
<Cale> So it's not really a problem.  [04:44:40]
<Cale> I like global well-ordering :)  [04:44:52]
<centrinia> Is the ZF axioms consistent?  [04:44:58]
* BMeph boggles  [04:45:01]
<BMeph> There's an official website for Robert Picardo?!?  [04:45:19]
<Cale> centrinia: We hope that ZF can't prove its own consistency.  [04:45:26]
<Cale> centrinia: Because if it can, then it's inconsistent.  [04:45:35]
<eu-prleu-peupeu> it would be nice to have a monad "goto" operator :D
                                                                     [04:45:39]
<eu-prleu-peupeu> in haskell  [04:45:40]
<arw> buah.  [04:45:49]
<eu-prleu-peupeu> just to say that haskell has gotos  [04:45:52]
<Cale> eu-prleu-peupeu: Continuation monads can do that.
* gwern sics the raptors on eu-prleu-peupeu   [04:45:54]
<centrinia> eu-prleu-peupeu: Try the mdo construction.  [04:45:57]
<Cale> centrinia: So if you want to prove that ZF is consistent, you need to
       use another system to examine it, the consistency of which is going to
       be just as hard to verify.  [04:46:51]
<centrinia> Too bad Haskell doesn't allow self-modifying code.  [04:47:08]
<centrinia> Cale, what if I find another system to verify the system that was
            used to verify ZF?  [04:47:32]
<FunctorSalad> centrinia: the problem is if your cartesian product isn't in
               the form A^B  [04:48:07]
<Cale> centrinia: Well, you can do that as well. But there's no way to know
       that the outermost system is consistent.  [04:48:11]
<FunctorSalad> centrinia: a general cartesian product is of the form product{i
               in I} A_i  [04:48:25]
<centrinia> What if I = \product_{i \in I} A_i ?  [04:49:16]
<Cale> centrinia: ers  [04:50:11]
<centrinia> Cale?  [04:50:19]
<FunctorSalad> that's unpossible if |A_i| >= 2 for all i ;)  [04:50:27]
<Trinithis> For some reason, when I use getLine and use backspace, the
            backspace doesn't work properly. Instead it prints backspace
            characters. How would I fix this?  [04:53:59]
<Badger> IIRC, getLine doesn't do non-letters  [04:54:33]
*** Corun (n=Corun@94-193-40-216.zone7.bethere.co.uk) is now known as
    Terrorist  [04:54:38]
*** Terrorist (n=Corun@94-193-40-216.zone7.bethere.co.uk) is now known as
    Corun  [04:54:45]
* Badger shoots Corun.  [04:55:02]
<FunctorSalad> Trinithis: I don't really know, maybe it is something about
               your ghc being compiled without editline?  [04:55:05]
<Corun> Aargh!
<Cale> Trinithis: line buffering is off?  [04:55:10]
<Trinithis> i turned of buffering  [04:55:18]
<Badger> orite  [04:55:25]
* FunctorSalad still gets annoying ^J's in emacs ghci :(  [04:55:29]
* Badger irrelevant  [04:55:36]
<Cale> Trinithis: stdin must be line buffered for backspace to work  [04:55:51]
<FunctorSalad> (since 6.10)  [04:55:54]
<Trinithis> oh  [04:56:05]
<Trinithis> works nows thakns  [04:56:11]
* Nafai is excited for the RWH book club  [04:57:42]
<Nafai> But I suppose I should order the dead-trees version :)  [04:57:49]
<FunctorSalad> book club?  [04:58:04]
<Axman6> http://groups.google.com/group/real-world-haskell-book-club
                                                                     [04:58:21]
<lambdabot> Title: Real World Haskell Book Club | Google Groups  [04:58:22]
<idnar> the first rule of book club is, you do not talk about book club
                                                                     [04:58:26]
<Nafai> idnar: Dang it, I always forget that rule  [04:58:36]
<wchogg> Hahsturns out that all three authors are actually the same person,
         trying to start an anarchistic cult.  [04:58:58]

[‘ËÄ 12‘ÔÂ  4 2008]
*** Topic for #haskell: ["Real World Haskell: it is alive!", "The Haskell
    programming language", "http://haskell.org", "Paste: http://hpaste.org",
    "Logs: http://tunes.org/~nef/logs/haskell/"]  [04:59:30]
*** #haskell: topic set by dons, 10:49:38 2008/11/26
*** Users on #haskell: ManateeLazyCat Saizan_ monochrom jethr0 Trinithis p
    athos saccade_ linuxmain hd_ novas0x2a guenni alexei_ kowey Cale dibblego
    blueonyx Dako-kun Cthulhon| skorpan atenea danvet zeno hydo Yoric[DT]
    FunctorSalad erikc Lemmih centrinia dmwit_ jkramar BCoppens Corun
    pjdelport ikaros netx Lor Lamperi eu-prleu-peupeu tttm olsner araujo
    seafood mrsolo andyjgill astrolabe geezusfreeek gbacon d2dchat mwhitney
    zachk neun QplQyer markluffel dje_ ToRA|MSR_ 
*** Users on #haskell: saccade Deeem2031 mlesniak polymar loriel jsn zoq
    Pellwurst tomh madnificent bos mm_freak Trafalgard mikezackles paolino
    Twey sebaseba vixey arw willb mriou mattrepl lerkok satchiii AtnNn roderyk
    proq smg lambdabot sam_ SyntaxRebel_ andrewsw andun AnalogHole klugez
    arjanoosting opqdonut fnordus Zao Blub\0 Jaak matveev polux liesen jimki
    shepheb Botje czShadoW methos cjs fanf enolan ned yango MrDomino_ Eridius
    papermachine RayNbow BONUS_ 
*** Users on #haskell: Debolaz EmielRegis manicman tst__ gbeshers kayess
    arjanb jpcooper JaffaCake stephens rdd nominolo|msr kazimir lefant pizza_
    alex23 sw17ch BMeph Guest90792 GNU\caus11c faluf whoppix noZone1 hkBst
    joelpet mortenlysgaard dejones Igloo purple__ mapreduce cnwdup
    lurkymclurkleton jeremiah falseep trie kaol neurogeek||m aik ChilliX
    iggly_ Valodim OnionKnight iblechbot snhmib gander AshyIsMe Snark Itkovian
    takinitez bens__ clanehin Baughn dort hrehf 
*** Users on #haskell: saiam wchogg zax Daniel_H dolio trofi coldhak Spockz
    ksf Bleadof jberg QtPlatyp1s shintah aeolist Liskni_si therp ulfdoz
    nornagon agentzh al-maisan twanvl Beelsebob nominolo_ Dessous pumpkin_
    xinming_ drbean Saul solrize Lemonator Philonous1 tarbo z|Andy Korollary
    kryptiskt tredontho equanimi1y authentic Armored_Azrael Saizan
    JuanDaugherty Axioplase alexsuraci leimy loop gwern xd kpreid u_quark SamB
    Axman6 docmach maek roconnor borism tessier 
*** Users on #haskell: kynky mikv Jedai fredcy ArneB gpolo cladhaire xcthulhu_
    DuClare gnufied eno jaj PsiOmega welterde te aartist sereven kolmodin
    scook0 jeffersonheard dfeuer nathanic dblazakis ttmrichter_ amiri
    Riastradh Twigathy EvilTerran Guest4981383 qz jajamana1 sjanssen
    BfrOv3rfl0w dmead score cpfr Plareplane dufflebu1k Mr_Awesome gmaslov mlh
    ushdf helgim SamB_XP lament bjorkLinux jfredett keseldude oklopol
    thetallgu1 mrd Deewiant luite_ snigel_ netcat 
*** Users on #haskell: r3m0t_ funktio fophillips cognominal kpk sbahra
    sebbe1991 pchiusano leadnose djjack telexicon ystael kar-1 Taggnostr
    wolgo_ tylere zipMe hukolele mightybyte Ezla yahooooo rangaparma mopped_
    ajhager thetallguy British0zzy shachaf mjrosenb raxas cjb Khisanth
    bohanlon thingwath Shimei jimt Shurique maskd m90 dvekravy DarthShrine
    Aisling randomit1 hackage sbahra[] jan__ pauleeallen52 cinimod m4thrick
    birkenfeld tltstc lucca mux mercury^ djinni 
*** Users on #haskell: pythonist kennyv lanaer tchakkazulu Megant pshc davidL
    preflex jelmer SimonRC sutats Philippa gogonkt_ shapr nnunley smtms eyck
    atsampson Tigge Gabbie Soliah solrize_ lasts ehird webframp mml` pixel_
    sclv olahol Raevel trez p_l wagle glguy mfp _MaK_ Ferdirand cjay poliquin
    bd_ stalker_ jonafan Elly aleator edwinb matthew-_ karld allbery_b pragma_
    nothingmuch baaba glith earthy PHO_ @ChanServ rog def__ im_maciek anders^^
    slarba_ bynari syscrash   [04:59:31]
*** Users on #haskell: loupgaroublond StoneToad liff dancor Tomas Modius taari
    frederik SubStack wolverian xHemi TML noj Badger lunabot nwf byorgey Poeir
    tromp liyang pengrate ibid c9s kosmikus DrSyzygy Skyp markovChain nasloc__
    quicksilver viklund emma fadec blazzy maxote DarthMeh osfameron DustyDingo
    nemik juhp jml iratsu Nanar vegai Eelis fabjan boyscared levitation[A]
    mattam erg heavensrevenge xian m_stone daf dcoutts Wechner Japsu newt0n
    ksandstr kalven ahf 
*** Users on #haskell: mgregsond bmc_ mauke flori Apocalisp orbitz quuxman
    newsham felipe Nafai ziman agemo dionoea hesselink marmolak Giraffe wjt
    flux obraun wormcc stylus jmob cods Mitar sad0ur gdsx vincenz idnar
    MyCatVerbs tmoertel_away tote r0bby Laney Funjker_Boy22 ivan koninkje_away
    bran_ pcc1 tuukkah Spark laz0r clog twifkak Arnar desp znutar_ integral
    ertai xmux qebab grantrules rey_ nybyn rodge Ornedan IsoPallo_ MarcWeber
    Stephan202 gds mornfall ski_ 
*** Users on #haskell: decklin thorkilnaur Hunner malouin shawn__ chr1s joed
    hellige kokekola miasma Anthraxx shrimpx dcoutts_ sbok faXx C-Keen Pistahh
    dons chrisdone tvaal stevan Jiten thedward Caelum suiside issal admodum
    holzplatten dublpaws Choko Draconx tmielika inimino lispy Somni Vulpyne
    bockmabe mokus DRMacIver Sartak And[y] jql Vq^ explicitjelly grul ski__
    regulate lilac TOLUanckA 
*** #haskell URL: http://www.haskell.org/  [04:59:32]
<gwern> wchogg: that's absurd. I've seen two of them here at the same time
        chatting  [04:59:39]
*** #haskell modes: +tncL  [04:59:47]
*** #haskell was created on ‘ÐÇ‘ÆÚ‘ÈÕ 2006/11/26 14‘Ê±42‘·Ö48‘Ãë
<pizza_> lol  [05:00:11]

[‘ËÄ 12‘ÔÂ  4 2008]
*** Topic for #haskell: ["Real World Haskell: it is alive!", "The Haskell
    programming language", "http://haskell.org", "Paste: http://hpaste.org",
    "Logs: http://tunes.org/~nef/logs/haskell/"]  [10:32:58]
*** #haskell: topic set by dons, 10:49:38 2008/11/26
*** Users on #haskell: ManateeLazyCat kayess_ mjonsson amz voidseeker Lemmih
    dejones cnwdup smg puusorsa dino- O_4 doublec dolio pizza__ trie xhanjian
    gweiqi linuxmain Itkovian lambdabot kfish ikkebr Cthulhon Goober enolan_
    zeno guenni cknapp chylli brushbox_ marko pizza_ Hong_MinHee lazyshark
    kniu StoneToad_ synthasee paul424 gbeshers d2dchat dmwit_ SKuhn
    JuanDaugherty saccade_ proq ddarius FunctorSalad sebbe1991 blackh
    strmnnrmn oncenull nn-main ajhager dort 
*** Users on #haskell: intrados u51z3h4 DarthShr1ne Peaker Nshag Saizan_
    novas0x2a Cale dibblego hydo jkramar pjdelport Lor Lamperi tttm araujo
    mrsolo gbacon mwhitney markluffel dje_ ToRA|MSR_ saccade loriel
    madnificent mm_freak Trafalgard Twey arw willb mattrepl roderyk
    SyntaxRebel andrewsw andun AnalogHole klugez arjanoosting opqdonut fnordus
    Zao Blub\0 Jaak matveev polux liesen jimki shepheb Botje czShadoW methos
    cjs fanf ned yango MrDomino_ Eridius Debolaz 
*** Users on #haskell: EmielRegis kayess jpcooper JaffaCake stephens rdd
    nominolo|msr lefant sw17ch BMeph Guest90792 GNU\caus11c whoppix noZone1
    joelpet Igloo purple__ mapreduce jeremiah falseep kaol ChilliX iggly_
    OnionKnight bens__ clanehin Baughn saiam wchogg trofi coldhak ksf Bleadof
    jberg QtPlatyp1s Liskni_si therp nornagon agentzh Beelsebob nominolo_
    xinming_ drbean solrize Philonous1 tarbo z|Andy Korollary tredontho
    equanimi1y authentic Armored_Azrael 
*** Users on #haskell: Axioplase alexsuraci leimy loop gwern xd kpreid u_quark
    SamB docmach maek roconnor borism tessier kynky mikv Jedai fredcy ArneB
    gpolo clad|sleep xcthulhu_ DuClare gnufied eno jaj PsiOmega welterde te
    sereven kolmodin scook0 jeffersonheard dfeuer nathanic dblazakis
    ttmrichter_ Riastradh Twigathy EvilTerran qz sjanssen dmead score cpfr
    Plareplane dufflebu1k Mr_Awesome gmaslov mlh ushdf helgim SamB_XP lament
    bjorkLinux jfredett keseldude oklopol 
*** Users on #haskell: thetallgu1 mrd Deewiant luite_ snigel_ netcat r3m0t_
    funktio fophillips kpk sbahra pchiusano leadnose djjack telexicon ystael
    kar-1 Taggnostr wolgo_ tylere zipMe hukolele mightybyte Ezla yahooooo
    rangaparma mopped_ thetallguy British0zzy shachaf mjrosenb raxas cjb
    Khisanth bohanlon thingwath Shimei jimt Shurique maskd m90 dvekravy
    Aisling randomit1 hackage sbahra[] jan__ pauleeallen52 cinimod m4thrick
    birkenfeld tltstc lucca mux mercury^ 
*** Users on #haskell: djinni pythonist kennyv lanaer tchakkazulu Megant pshc
    davidL preflex jelmer SimonRC sutats Philippa gogonkt_ shapr nnunley smtms
    eyck atsampson Tigge Gabbie Soliah solrize_ lasts ehird webframp mml`
    pixel_ sclv olahol Raevel trez p_l wagle glguy mfp _MaK_ Ferdirand cjay
    poliquin bd_ stalker_ jonafan Elly aleator edwinb matthew-_ karld
    allbery_b pragma_ nothingmuch baaba glith earthy PHO_ @ChanServ rog def__
    im_maciek anders^^ slarba_ bynari 
*** Users on #haskell: syscrash loupgaroublond liff dancor Tomas Modius taari
    frederik SubStack wolverian xHemi TML noj Badger lunabot nwf byorgey Poeir
    tromp liyang pengrate ibid c9s kosmikus DrSyzygy Skyp markovChain nasloc__
    quicksilver viklund emma fadec blazzy maxote DarthMeh osfameron DustyDingo
    nemik juhp jml iratsu Nanar vegai Eelis fabjan boyscared levitation[A]
    mattam erg heavensrevenge xian m_stone daf dcoutts Wechner Japsu newt0n
    ksandstr kalven ahf 
*** Users on #haskell: mgregsond bmc_ mauke flori Apocalisp orbitz quuxman
    newsham felipe Nafai ziman agemo dionoea hesselink marmolak Giraffe wjt
    flux obraun wormcc stylus jmob cods Mitar sad0ur gdsx vincenz idnar
    MyCatVerbs tmoertel_away tote r0bby Laney Funjker_Boy22 ivan lilac
    regulate ski__ grul koninkje_away explicitjelly Vq^ jql And[y] Sartak
    DRMacIver mokus bockmabe Vulpyne Somni lispy inimino tmielika Draconx
    Choko dublpaws holzplatten admodum issal 
*** Users on #haskell: suiside Caelum thedward Jiten stevan tvaal chrisdone
    dons Pistahh C-Keen faXx sbok dcoutts_ shrimpx Anthraxx miasma kokekola
    joed hellige chr1s shawn__ malouin Hunner thorkilnaur decklin ski_
    mornfall gds Stephan202 MarcWeber IsoPallo_ Ornedan rodge nybyn rey_
    grantrules qebab xmux integral znutar_ desp Arnar twifkak clog laz0r Spark
    tuukkah pcc1 bran_ ertai 
*** #haskell URL: http://www.haskell.org/  [10:33:00]

[‘ËÄ 12‘ÔÂ  4 2008]
*** Topic for #haskell: ["Real World Haskell: it is alive!", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org",
    "Logs: http://tunes.org/~nef/logs/haskell/"]  [13:40:05]
*** #haskell: topic set by dons, 10:49:38 2008/11/26
*** Users on #haskell: ManateeLazyCat drbean_ travisbrady u_quark mlesniak path[l] appletizer exbio bos Dessous jeffz` dmwit papermachine Saul kniu
    aculich thoughtpolice Philonous kar-1 solussd Saizan jelmer andyjgill binrapt polymar Millz telexicon alc samky zeno_ erg0t Raynes centrinia
    nn64 hd_ kpreid hansfbaier Axman6 kayess_ mjonsson Lemmih dejones cnwdup smg puusorsa dino- doublec dolio pizza__ xhanjian linuxmain Itkovian
    lambdabot kfish Cthulhon Goober enolan_ 
*** Users on #haskell: cknapp chylli brushbox_ marko pizza_ Hong_MinHee lazyshark StoneToad_ synthasee paul424 gbeshers SKuhn JuanDaugherty
    saccade_ proq ddarius FunctorSalad sebbe1991 blackh strmnnrmn nn-main ajhager dort intrados u51z3h4 DarthShr1ne Peaker Cale dibblego hydo
    jkramar pjdelport Lor Lamperi tttm araujo gbacon mwhitney markluffel dje_ ToRA|MSR_ saccade loriel madnificent mm_freak Trafalgard Twey arw
    roderyk SyntaxRebel andrewsw andun AnalogHole 
*** Users on #haskell: klugez arjanoosting opqdonut fnordus Zao Blub\0 Jaak matveev polux liesen jimki shepheb Botje czShadoW methos cjs fanf ned
    yango MrDomino_ Eridius Debolaz jpcooper JaffaCake rdd nominolo|msr lefant sw17ch Guest90792 GNU\caus11c whoppix noZone1 Igloo purple__
    mapreduce jeremiah falseep kaol ChilliX iggly_ OnionKnight bens__ clanehin Baughn saiam wchogg trofi coldhak ksf Bleadof QtPlatyp1s Liskni_si
    therp nornagon agentzh Beelsebob nominolo_ 
*** Users on #haskell: xinming_ solrize tarbo z|Andy Korollary tredontho equanimi1y authentic Armored_Azrael Axioplase alexsuraci leimy loop gwern
    xd SamB docmach maek roconnor borism tessier kynky mikv Jedai fredcy ArneB gpolo clad|sleep xcthulhu_ DuClare eno jaj PsiOmega welterde te
    sereven kolmodin scook0 jeffersonheard dfeuer nathanic dblazakis ttmrichter_ Riastradh Twigathy EvilTerran qz sjanssen dmead score cpfr
    Plareplane dufflebu1k Mr_Awesome mlh ushdf 
*** Users on #haskell: helgim SamB_XP lament bjorkLinux jfredett keseldude oklopol thetallgu1 mrd Deewiant luite_ snigel_ netcat r3m0t_ funktio
    fophillips kpk sbahra pchiusano leadnose djjack ystael Taggnostr wolgo_ tylere zipMe hukolele mightybyte Ezla yahooooo rangaparma mopped_
    thetallguy British0zzy shachaf mjrosenb raxas cjb Khisanth bohanlon thingwath Shimei Shurique maskd m90 dvekravy Aisling randomit1 hackage
    sbahra[] jan__ pauleeallen52 cinimod m4thrick 
*** Users on #haskell: birkenfeld tltstc lucca mux mercury^ djinni pythonist kennyv lanaer tchakkazulu Megant pshc davidL preflex SimonRC sutats
    Philippa gogonkt_ shapr nnunley smtms eyck atsampson Tigge Gabbie Soliah solrize_ lasts ehird webframp mml` pixel_ sclv olahol Raevel trez p_l
    wagle glguy mfp _MaK_ Ferdirand cjay poliquin bd_ stalker_ jonafan Elly aleator edwinb matthew-_ karld allbery_b pragma_ nothingmuch baaba
    glith earthy PHO_ @ChanServ rog def__ 
*** Users on #haskell: im_maciek anders^^ slarba_ bynari syscrash loupgaroublond liff dancor Tomas Modius taari frederik SubStack wolverian xHemi
    TML noj Badger lunabot nwf byorgey Poeir tromp liyang pengrate ibid c9s kosmikus DrSyzygy Skyp markovChain nasloc__ quicksilver viklund emma
    fadec blazzy maxote DarthMeh osfameron DustyDingo nemik juhp jml iratsu Nanar vegai Eelis fabjan boyscared levitation[A] mattam erg
    heavensrevenge xian m_stone daf dcoutts Wechner 
*** Users on #haskell: Japsu newt0n ksandstr kalven ahf mgregsond bmc_ mauke flori Apocalisp orbitz quuxman newsham felipe Nafai ziman agemo
    dionoea hesselink marmolak Giraffe wjt flux obraun wormcc stylus jmob cods Mitar sad0ur gdsx vincenz idnar MyCatVerbs tmoertel_away tote r0bby
    Laney Funjker_Boy22 ivan lilac regulate ski__ grul koninkje_away explicitjelly Vq^ jql And[y] Sartak DRMacIver mokus bockmabe Vulpyne Somni
    lispy inimino tmielika Draconx Choko dublpaws 
*** Users on #haskell: holzplatten admodum issal suiside Caelum thedward Jiten stevan tvaal chrisdone dons Pistahh C-Keen faXx sbok dcoutts_
    shrimpx Anthraxx miasma kokekola joed hellige chr1s shawn__ malouin Hunner thorkilnaur decklin ski_ mornfall gds Stephan202 MarcWeber IsoPallo_
    Ornedan rodge nybyn rey_ qebab xmux ertai bran_ pcc1 tuukkah Spark laz0r clog twifkak Arnar desp znutar_ integral 
*** #haskell URL: http://www.haskell.org/  [13:40:06]
*** #haskell: [freenode-info] please register your nicknamesdon't forget to auto-identify! http://freenode.net/faq.shtml#nicksetup
*** #haskell modes: +tncL  [13:40:30]
*** #haskell was created on ‘ÐÇ‘ÆÚ‘ÈÕ 2006/11/26 14‘Ê±42‘·Ö48‘Ãë
<Cthulhon> That's never true of a monad?  [13:40:52]
<Saizan> while with (>>=) :: m a -> (a -> m b) -> m b, the second argument has the freedom to construct the "m b" by looking at "a"  [13:41:13]
<Saizan> well, it can be true for certain expressions  [13:41:57]
<Saizan> those that you write with only ap and return, for example :)  [13:42:50]
*** zeno_ (n=andrew@97-112-134-206.clsp.qwest.net) is now known as zeno  [13:43:05]
<Cthulhon> Ah.  [13:43:07]
<Saizan> so, the Monad interface is more expressive, but if you restrict yourself to Applicative you know more about your expressions before
         starting to "execute" them  [13:44:52]
<Saizan> which is exploited by some parsing libraries to auto-optimize the parsers you define, for example  [13:46:56]
<Cthulhon> Neat.  [13:47:35]
<nn64> >777+777  [13:54:03]
<dmwit> needs more space  [13:54:11]
<dmwit> > 777+777  [13:54:14]
<dmwit> Also, needs more \bot.  [13:54:30]
<dmwit> ?bot  [13:54:31]
<lament> lambdabot just needs some space  [13:54:33]
<nn64> > 777+789+777  [13:55:02]
<dmwit> Sorry, but lambdabot seems to be out of commission for now.  [13:55:18]
<dmwit> Time to fire up ghci. =)  [13:55:26]
<nn64> dmwit, lets test my bot then  [13:56:04]
<grom358> @src rem  [13:56:06]
<nn64> join the irc at linuxmain.net and join #linux  [13:56:24]
<dmwit> grom358: It's a class function, and for many types the implementation is just a call to some primitive builtin.  [13:56:30]
<grom358> > -6 `rem` 2  [13:58:13]
* Cale wonders if lambdabot is dead.  [13:58:28]
<Cale> @bot  [13:58:30]
<lunabot>  :)
<Cale> hmm  [13:58:34]
* ksf suddenly remembers himself in the first grade, thinking about circles and whether or not they got zero or infinite corners. he decided on infinite
  and now corrects that to finite.  [13:58:57]
<Cale> ah, url module failed in contextual handler: thread killed  [13:59:19]
<lament> circles have FOUR corners you stupid fool.  [13:59:29]
<grom358> ksf: what?  [13:59:32]
<ksf> circle? four?  [13:59:47]
<Cale> > -6 `rem` 2  [13:59:48]
<ksf> it's bounding box has.  [13:59:52]
<lambdabot>   0  [13:59:54]

[‘ËÄ 12‘ÔÂ  4 2008]
*** Topic for #haskell: ["Real World Haskell: it is alive!", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs:
    http://tunes.org/~nef/logs/haskell/"]  [14:01:54]
*** #haskell: topic set by dons, 10:49:38 2008/11/26
*** Users on #haskell: ManateeLazyCat lambdabot Lemmih grom358 mgregson papermachine jsn xinming drbean_ travisbrady u_quark mlesniak path[l] appletizer
    exbio bos Dessous jeffz` dmwit Saul kniu aculich thoughtpolice Philonous kar-1 Saizan jelmer andyjgill binrapt telexicon alc zeno erg0t centrinia
    nn64 hd_ kpreid hansfbaier Axman6 kayess_ mjonsson dejones cnwdup smg puusorsa dino- doublec dolio pizza__ xhanjian linuxmain Itkovian kfish Cthulhon
    Goober enolan_ cknapp 
*** Users on #haskell: chylli brushbox_ marko pizza_ Hong_MinHee lazyshark StoneToad_ synthasee paul424 gbeshers SKuhn JuanDaugherty saccade_ proq
    ddarius sebbe1991 blackh strmnnrmn nn-main ajhager dort intrados u51z3h4 DarthShr1ne Peaker Cale dibblego hydo jkramar pjdelport Lor Lamperi tttm
    araujo gbacon mwhitney markluffel dje_ ToRA|MSR_ saccade loriel madnificent mm_freak Trafalgard Twey arw roderyk SyntaxRebel andrewsw andun
    AnalogHole klugez arjanoosting opqdonut   [14:01:55]
*** Users on #haskell: fnordus Zao Blub\0 Jaak matveev polux liesen jimki shepheb Botje czShadoW methos cjs fanf ned yango MrDomino_ Eridius Debolaz
    jpcooper JaffaCake rdd nominolo|msr lefant sw17ch Guest90792 GNU\caus11c whoppix noZone1 Igloo purple__ mapreduce jeremiah falseep kaol ChilliX
    iggly_ OnionKnight bens__ clanehin Baughn saiam wchogg trofi coldhak ksf Bleadof QtPlatyp1s Liskni_si therp nornagon agentzh Beelsebob nominolo_
    solrize tarbo z|Andy Korollary 
*** Users on #haskell: tredontho equanimi1y authentic Armored_Azrael Axioplase alexsuraci leimy loop gwern xd SamB docmach maek roconnor borism tessier
    kynky mikv Jedai fredcy ArneB gpolo clad|sleep xcthulhu_ DuClare eno jaj PsiOmega welterde te sereven kolmodin scook0 jeffersonheard dfeuer nathanic
    dblazakis ttmrichter_ Riastradh Twigathy EvilTerran qz sjanssen dmead score cpfr Plareplane dufflebu1k Mr_Awesome mlh ushdf helgim SamB_XP lament
    bjorkLinux jfredett 
*** Users on #haskell: keseldude oklopol thetallgu1 mrd Deewiant luite_ snigel_ netcat r3m0t_ funktio fophillips kpk sbahra pchiusano leadnose djjack
    ystael Taggnostr wolgo_ tylere zipMe hukolele mightybyte Ezla yahooooo rangaparma mopped_ thetallguy British0zzy shachaf mjrosenb raxas cjb Khisanth
    bohanlon thingwath bran_ pcc1 tuukkah Spark laz0r clog twifkak Arnar desp znutar_ integral ertai xmux qebab rey_ nybyn rodge Ornedan IsoPallo_
    MarcWeber Stephan202 gds 
*** Users on #haskell: mornfall ski_ decklin thorkilnaur Hunner malouin shawn__ chr1s joed hellige kokekola miasma Anthraxx shrimpx dcoutts_ sbok faXx
    C-Keen Pistahh dons chrisdone tvaal stevan Jiten thedward Caelum suiside issal admodum holzplatten dublpaws Choko Draconx tmielika inimino lispy
    Somni Vulpyne bockmabe mokus DRMacIver Sartak And[y] jql Vq^ explicitjelly grul ski__ regulate lilac koninkje_away ivan Funjker_Boy22 Laney r0bby
    tote tmoertel_away MyCatVerbs 
*** Users on #haskell: idnar vincenz gdsx sad0ur Mitar cods jmob stylus wormcc obraun flux wjt Giraffe marmolak hesselink dionoea agemo ziman Nafai
    felipe newsham quuxman orbitz Apocalisp flori mauke bmc_ mgregsond ahf kalven ksandstr newt0n Japsu Wechner dcoutts daf m_stone xian heavensrevenge
    erg mattam levitation[A] boyscared fabjan Eelis vegai Nanar iratsu jml juhp nemik DustyDingo osfameron DarthMeh maxote blazzy fadec emma viklund
    quicksilver nasloc__ markovChain 
*** Users on #haskell: Skyp DrSyzygy kosmikus c9s ibid pengrate liyang tromp Poeir byorgey nwf lunabot Badger noj TML xHemi wolverian SubStack frederik
    taari Modius Tomas dancor liff loupgaroublond syscrash bynari slarba_ anders^^ im_maciek def__ rog PHO_ earthy glith baaba nothingmuch pragma_
    allbery_b karld matthew-_ edwinb aleator Elly jonafan stalker_ bd_ poliquin cjay Ferdirand _MaK_ mfp glguy wagle p_l trez Raevel olahol sclv pixel_
    mml` webframp ehird lasts 
*** Users on #haskell: solrize_ Soliah Gabbie Tigge atsampson eyck smtms nnunley shapr gogonkt_ Philippa sutats SimonRC preflex davidL pshc Megant
    tchakkazulu lanaer kennyv pythonist djinni mercury^ mux lucca tltstc birkenfeld m4thrick cinimod pauleeallen52 jan__ sbahra[] hackage randomit1
    Aisling dvekravy m90 maskd Shurique Shimei @ChanServ 
*** #haskell URL: http://www.haskell.org/  [14:01:56]
<ksf> lament, how big a coin do you need to approximate pi to n digits?
<Cale> nn64: You'll find it on hackage.  [14:02:02]
<lament> ksf: two dollars  [14:02:05]
*** #haskell modes: +tncL  [14:02:20]
*** #haskell was created on ‘ÐÇ‘ÆÚ‘ÈÕ 2006/11/26 14‘Ê±42‘·Ö48‘Ãë
<ksf> at current exchange rates?  [14:02:38]
<nn64> iecabal/bin/cabal install mueval  -bash: ../.cabal/bin/cabal: No such file or directory  [14:03:06]
<lament> you don't believe in exchange rates, because they're continuous  [14:03:07]
<ksf> they aren't, ask the next guy who implements them.  [14:03:38]
<ksf> both over time and over values.  [14:04:06]
<ksf> basically, yes, you won't ever see pi dollars.  [14:04:29]
<nn64> oups that error was my falt  [14:05:00]
<nn64> now it returns this :: <lambdabot>       Could not find module `Control.Arrow.Transformer.All':  [14:08:47]
<nn64> <lambdabot>        Use -v tos  [14:08:48]
<nn64> any idea how to fix that  [14:11:31]
<ksf> if you oppose two mirrors, do they reflect photons infinitely?  [14:12:01]
<ksf> strangely enough, but in that case, infinity is limited by at least light speed.  [14:12:27]
<nn64> ah h :( its getting to late I will have to work on this tomarrow  [14:13:08]
<joed> Me claps with one hand for ksf's brilliant koanss  [14:13:10]
<lazyshark> Hi, does anyone know if the H3D project is active? (http://www.haskell.org/haskellwiki/H3D)  [14:14:15]
<lambdabot> Title: H3D - HaskellWiki  [14:14:16]

[‘ËÄ 12‘ÔÂ  4 2008]
*** Topic for #haskell: ["Real World Haskell: it is alive!", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs:
    http://tunes.org/~nef/logs/haskell/"]  [23:03:55]
*** #haskell: topic set by dons, 10:49:38 2008/11/26
*** Users on #haskell: ManateeLazyCat dmwit hallongrottan BMeph sebaseba igel_ Taggnostr willb joelpet_ macondo OnionKnight semka zeno__ tomh whoppix
    anRch Deeem2031 itnomad pierre- moofbong Neun twanvl_ aik dolio gabor_ Valodim trie dort omichael yakov thingwath athos Lemmih lurkymclurkleton
    kristofer joelpet ikkebr Asztal cognominal faluf silentbob vpalle pizza__ solussd neurogeek||m xanonus vixey camio cknapp Dessous tst__ goober ikaros
    ttmrichter plikk 
*** Users on #haskell: darka voidseeker xhanjian ulfdoz Yaquishael zever vaskaren Daniel_H igel hrehf mlesniak dblhelix raxas erg0t kpreid Eleanore int-e
    elias` mornfall titusg Snark der_eq lekro lorandi zax Spockz __me hugo___ RayNbow u_quark Nshag malcolmw fschwidom mapreduce Toxaris shrimpx
    pcapriotti gnufied niksnut Twey tttm astrobunny Eridius swiert kayess__ jamii timchen1` drbean iblechbot paolino nornagon mishok13 aculich jajamana
    shintah yav papermachine 
*** Users on #haskell: Axman6_ jjong BeelsebobWork_ jberg chipdude noob_hs cnwdup al-maisan saccade_ sbahra ksf dreixel integral znutar_ desp Arnar
    twifkak clog laz0r Spark tuukkah pcc1 bran_ ertai xmux qebab rey_ nybyn rodge Ornedan IsoPallo_ MarcWeber Stephan202 gds ski_ decklin thorkilnaur
    Hunner malouin shawn__ chr1s hellige joed kokekola miasma Anthraxx dcoutts_ sbok faXx C-Keen Pistahh dons chrisdone tvaal stevan Jiten thedward
    Caelum suiside issal admodum 
*** Users on #haskell: holzplatten dublpaws Choko Draconx tmielika inimino lispy Somni Vulpyne bockmabe mokus DRMacIver Sartak And[y] jql Vq^
    explicitjelly koninkje_away grul ski__ regulate lilac ivan Funjker_Boy22 Laney r0bby tote tmoertel_away MyCatVerbs idnar vincenz gdsx sad0ur Mitar
    cods jmob stylus wormcc obraun flux wjt Giraffe marmolak hesselink dionoea agemo ziman Nafai felipe newsham quuxman orbitz Apocalisp flori mauke bmc_
    mgregsond ahf kalven ksandstr 
*** Users on #haskell: newt0n Japsu Wechner dcoutts daf m_stone xian heavensrevenge erg mattam levitation[A] boyscared fabjan Eelis vegai Nanar iratsu
    jml juhp nemik DustyDingo osfameron DarthMeh maxote blazzy fadec emma viklund quicksilver markovChain Skyp DrSyzygy kosmikus c9s ibid pengrate liyang
    tromp Poeir byorgey nwf lunabot Badger noj TML xHemi wolverian SubStack frederik taari Modius Tomas dancor liff loupgaroublond syscrash bynari
    slarba_ anders^^ 
*** Users on #haskell: im_maciek def__ rog PHO_ earthy glith baaba pragma_ allbery_b karld matthew-_ edwinb aleator Elly jonafan stalker_ bd_ poliquin
    cjay Ferdirand _MaK_ mfp glguy wagle p_l trez Raevel olahol sclv pixel_ mml` webframp ehird lasts solrize_ Soliah Gabbie Tigge atsampson eyck smtms
    nnunley shapr gogonkt_ Philippa sutats SimonRC preflex davidL pshc Megant tchakkazulu lanaer kennyv pythonist djinni mercury^ mux lucca tltstc
    birkenfeld m4thrick 
*** Users on #haskell: cinimod pauleeallen52 jan__ sbahra[] randomit1 Aisling dvekravy m90 Shurique Khisanth cjb mjrosenb shachaf British0zzy thetallguy
    mopped_ yahooooo mightybyte hukolele zipMe tylere wolgo_ ystael djjack leadnose pchiusano kpk fophillips funktio r3m0t_ netcat snigel_ luite_
    Deewiant mrd thetallgu1 keseldude jfredett bjorkLinux lament SamB_XP helgim ushdf mlh Mr_Awesome dufflebu1k Plareplane cpfr score dmead EvilTerran
    Twigathy Riastradh   [23:03:56]
*** Users on #haskell: dblazakis nathanic jeffersonheard scook0 kolmodin sereven welterde PsiOmega jaj DuClare xcthulhu_ clad|sleep gpolo ArneB fredcy
    Jedai kynky tessier borism roconnor docmach SamB xd gwern alexsuraci Axioplase Armored_Azrael authentic equanimi1y MacTavish z|Andy tarbo solrize
    nominolo_ Beelsebob agentzh therp Liskni_si QtPlatyp1s Bleadof coldhak saiam Baughn clanehin iggly_ ChilliX kaol falseep Igloo noZone1 GNU\caus11c
    Guest90792 lefant 
*** Users on #haskell: nominolo|msr rdd JaffaCake jpcooper Debolaz MrDomino_ yango ned fanf cjs methos czShadoW Botje shepheb jimki liesen polux matveev
    Jaak Blub\0 Zao fnordus opqdonut arjanoosting klugez andun andrewsw SyntaxRebel roderyk arw mm_freak madnificent saccade ToRA|MSR_ markluffel
    mwhitney gbacon Lamperi Lor pjdelport jkramar hydo dibblego Cale Peaker DarthShrine intrados ajhager nn-main strmnnrmn sebbe1991 proq JuanDaugherty
    StoneToad enolan_ 
*** Users on #haskell: Cthulhon Itkovian linuxmain pizza_ dino- puusorsa telexicon binrapt jelmer Saizan kar-1 thoughtpolice kniu exbio lambdabot BONUS
    harinath bohanlon` loop Guest54910 te sjanssen eno xinming_ Philonous leimy purple__ @ChanServ jeremiah hackage 
*** #haskell URL: http://www.haskell.org/  [23:03:57]
<ksf> vixey, i sincerely have no idea at all.
<ksf> I just know they run lisp.  [23:04:01]
<ksf> In hardware.  [23:04:05]
*** #haskell modes: +tncL  [23:04:16]
*** #haskell was created on ‘ÐÇ‘ÆÚ‘ÈÕ 2006/11/26 14‘Ê±42‘·Ö48‘Ãë
<Philippa> Beelsebob: by analogy rather than straight-up, usually  [23:04:33]
<ksf> and got at least cons/car/cdr/gc as primitives  [23:04:35]
<Philippa> otherwise, nothing but the physical representations for symbols you're pushing around is concrete  [23:05:15]

[‘Îå 12‘ÔÂ  5 2008]
*** Topic for #haskell: ["Real World Haskell: it is alive!", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs:
    http://tunes.org/~nef/logs/haskell/"]  [11:45:08]
*** #haskell: topic set by dons, 10:49:38 2008/11/26
*** Users on #haskell: ManateeLazyCat u_quark papermachine Adamant dmwit lpjhjdh doublec bos wy conal _kayess saccade_ scook0 luqui mriou naradapuri
    gio123 solussd ttmrichter_ aculich twb Korollary yuuki gogonkt kpreid zeno__ Philippa_ geezusfreeek dv_ hansfbaier harinath Lemmih pumpkin xhanjian
    george__ cnwdup d2dchat_ gweiqi mattrepl edwardk oncenull polveroj takinitez_ Valodim_ dfeuer smg Hong_MinHee jekor Peaker pizza__ ozy` EmielRegis
    paulrd synthasee oklopol 
*** Users on #haskell: ksf AnalogHole CoryDambach jelmer dort ddarius O_4 FunctorSalad Sgeo kniu mikezackles rdd AtnNn blackh thingwath thoughtpolice
    davidL BobFunk jeremiah monochrom kokekola elias` kfish Twey jsn brushbox baaba MrDomino Deeem2031 dje_ djinni araujo Modius Trafalgard arjanb
    ulfdoz_ semka jan_ JuanDaugherty Shimei syscrash mmorrow mgregson u51z3h4 easytiger rangaparma marko dejones JaffaCake ToRA|MSR wchogg telexicon
    atsampson Taggnostr OnionKnight 
*** Users on #haskell: twanvl_ ikkebr_gone_comp cognominal pizza_ goober raxas mornfall mapreduce shrimpx gnufied tttm astrobunny Eridius nasloc__ drbean
    nornagon mishok13 jajamana chipdude sbahra hackage purple__ leimy xinming_ eno sjanssen te maek loop bohanlon lambdabot exbio kar-1 Saizan puusorsa
    dino- linuxmain Cthulhon StoneToad proq sebbe1991 strmnnrmn ajhager intrados DarthShrine Cale dibblego pjdelport Lor Lamperi gbacon mwhitney saccade
    madnificent 
*** Users on #haskell: mm_freak arw SyntaxRebel andrewsw andun klugez arjanoosting opqdonut fnordus Zao Blub\0 Jaak matveev polux liesen jimki shepheb
    Botje czShadoW methos cjs fanf ned yango Debolaz lefant Guest90792 GNU\caust1c noZone1 Igloo falseep kaol iggly_ clanehin Baughn saiam coldhak
    Bleadof QtPlatyp1s Liskni_si therp agentzh Beelsebob nominolo_ tarbo z|Andy MacTavish equanimi1y authentic Armored_Azrael Axioplase alexsuraci gwern
    SamB docmach roconnor 
*** Users on #haskell: borism tessier kynky Jedai fredcy ArneB gpolo clad|sleep xcthulhu_ DuClare jaj PsiOmega welterde sereven kolmodin jeffersonheard
    nathanic dblazakis Riastradh Twigathy EvilTerran dmead score cpfr Plareplane dufflebu1k Mr_Awesome mlh helgim SamB_XP lament bjorkLinux jfredett
    keseldude thetallgu1 mrd Deewiant luite_ snigel_ netcat r3m0t_ funktio fophillips kpk pchiusano leadnose djjack wolgo_ tylere hukolele mightybyte
    yahooooo mopped_ thetallguy 
*** Users on #haskell: British0zzy shachaf mjrosenb cjb Khisanth Shurique m90 dvekravy Aisling randomit1 sbahra[] pauleeallen52 cinimod m4thrick
    birkenfeld tltstc lucca mux mercury^ pythonist kennyv lanaer tchakkazulu Megant pshc preflex SimonRC sutats Philippa shapr nnunley smtms eyck Tigge
    Gabbie Soliah solrize_ lasts webframp mml` pixel_ sclv olahol Raevel trez p_l wagle glguy mfp _MaK_ Ferdirand cjay poliquin bd_ stalker_ jonafan Elly
    aleator edwinb matthew-_ 
*** Users on #haskell: karld allbery_b pragma_ glith earthy PHO_ @ChanServ rog def__ im_maciek anders^^ slarba_ bynari loupgaroublond liff dancor Tomas
    taari frederik SubStack wolverian xHemi TML noj Badger lunabot nwf byorgey Poeir tromp liyang pengrate ibid c9s kosmikus DrSyzygy Skyp markovChain
    quicksilver viklund emma fadec maxote DarthMeh osfameron DustyDingo nemik juhp jml iratsu Nanar vegai Eelis fabjan boyscared levitation[A] mattam erg
    heavensrevenge 
*** Users on #haskell: m_stone daf dcoutts Wechner Japsu newt0n ksandstr kalven ahf mgregsond bmc_ mauke flori Apocalisp orbitz quuxman newsham felipe
    Nafai ziman agemo dionoea hesselink marmolak Giraffe wjt flux obraun wormcc stylus jmob cods Mitar sad0ur gdsx vincenz idnar MyCatVerbs tmoertel_away
    tote r0bby Laney Funjker_Boy22 ivan lilac regulate ski__ grul koninkje_away explicitjelly Vq^ jql And[y] Sartak DRMacIver mokus bockmabe Vulpyne
    Somni lispy inimino 
*** Users on #haskell: tmielika Draconx Choko dublpaws holzplatten admodum issal suiside Caelum thedward Jiten stevan tvaal chrisdone dons Pistahh C-Keen
    faXx sbok dcoutts_ Anthraxx miasma joed hellige chr1s shawn__ malouin Hunner thorkilnaur decklin ski_ gds Stephan202 MarcWeber IsoPallo_ Ornedan
    rodge nybyn rey_ qebab xmux ertai bran_ pcc1 tuukkah Spark laz0r clog twifkak Arnar desp znutar_ integral 
*** #haskell URL: http://www.haskell.org/  [11:45:09]
*** #haskell modes: +tncL  [11:45:30]
*** #haskell was created on ‘ÐÇ‘ÆÚ‘ÈÕ 2006/11/26 14‘Ê±42‘·Ö48‘Ãë
<twb> Hmm, looks like Yi's config format has changed again since last I used it  [11:47:48]
<twb> I have a YiConfig.hs with yiMain, but it seems to want a yi.hs with main.  [11:48:10]
<wy> polveroj: I see. So the monad type can only have one parameter. That is the type of the "value"?  [11:48:51]

[‘Îå 12‘ÔÂ  5 2008]
*** Topic for #haskell: ["Real World Haskell: it is alive!", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs:
    http://tunes.org/~nef/logs/haskell/"]  [11:51:42]
*** #haskell: topic set by dons, 10:49:38 2008/11/26
*** Users on #haskell: ManateeLazyCat hydo u_quark papermachine Adamant dmwit lpjhjdh doublec bos wy conal _kayess saccade_ scook0 luqui mriou naradapuri
    gio123 solussd ttmrichter_ aculich twb Korollary yuuki gogonkt kpreid zeno__ Philippa_ geezusfreeek dv_ hansfbaier harinath Lemmih pumpkin xhanjian
    george__ cnwdup d2dchat_ gweiqi mattrepl edwardk oncenull polveroj takinitez_ Valodim_ dfeuer smg Hong_MinHee jekor Peaker pizza__ ozy` EmielRegis
    paulrd synthasee 
*** Users on #haskell: oklopol ksf AnalogHole CoryDambach jelmer dort ddarius O_4 FunctorSalad Sgeo kniu mikezackles rdd AtnNn blackh thingwath
    thoughtpolice davidL BobFunk jeremiah monochrom kokekola elias` kfish Twey jsn brushbox baaba MrDomino Deeem2031 dje_ djinni araujo Modius Trafalgard
    arjanb ulfdoz_ semka jan_ JuanDaugherty Shimei syscrash mmorrow mgregson u51z3h4 easytiger rangaparma marko dejones JaffaCake ToRA|MSR wchogg
    telexicon atsampson Taggnostr 
*** Users on #haskell: OnionKnight ikkebr_gone_comp cognominal pizza_ goober raxas mornfall mapreduce shrimpx gnufied tttm astrobunny Eridius nasloc__
    drbean nornagon mishok13 jajamana chipdude sbahra hackage purple__ leimy xinming_ eno sjanssen te maek loop bohanlon lambdabot exbio kar-1 Saizan
    puusorsa dino- linuxmain Cthulhon StoneToad proq sebbe1991 strmnnrmn ajhager intrados DarthShrine Cale dibblego pjdelport Lor Lamperi gbacon mwhitney
    saccade madnificent 
*** Users on #haskell: mm_freak arw SyntaxRebel andrewsw andun klugez arjanoosting opqdonut fnordus Zao Blub\0 Jaak matveev polux liesen jimki shepheb
    Botje czShadoW methos cjs fanf ned yango Debolaz lefant Guest90792 GNU\caust1c noZone1 Igloo falseep kaol iggly_ clanehin Baughn saiam coldhak
    Bleadof QtPlatyp1s Liskni_si therp agentzh Beelsebob nominolo_ tarbo z|Andy MacTavish equanimi1y authentic Armored_Azrael Axioplase alexsuraci gwern
    SamB docmach roconnor 
*** Users on #haskell: borism tessier kynky Jedai fredcy ArneB gpolo clad|sleep xcthulhu_ DuClare jaj PsiOmega welterde sereven kolmodin jeffersonheard
    nathanic dblazakis Riastradh Twigathy EvilTerran dmead score cpfr Plareplane dufflebu1k Mr_Awesome mlh helgim SamB_XP lament bjorkLinux jfredett
    keseldude thetallgu1 mrd Deewiant luite_ snigel_ netcat r3m0t_ funktio fophillips kpk pchiusano leadnose djjack wolgo_ tylere hukolele mightybyte
    yahooooo mopped_ thetallguy 
*** Users on #haskell: British0zzy shachaf mjrosenb cjb Khisanth Shurique m90 dvekravy Aisling randomit1 sbahra[] pauleeallen52 cinimod m4thrick
    birkenfeld tltstc lucca mux mercury^ pythonist kennyv lanaer tchakkazulu Megant pshc preflex SimonRC sutats Philippa shapr nnunley smtms eyck Tigge
    Gabbie Soliah solrize_ lasts webframp mml` pixel_ sclv olahol Raevel trez p_l wagle glguy mfp _MaK_ Ferdirand cjay poliquin bd_ stalker_ jonafan Elly
    aleator edwinb matthew-_ 
*** Users on #haskell: karld allbery_b pragma_ glith earthy PHO_ @ChanServ rog def__ im_maciek anders^^ slarba_ bynari loupgaroublond liff dancor Tomas
    taari frederik SubStack wolverian xHemi TML noj Badger lunabot nwf byorgey Poeir tromp liyang pengrate ibid c9s kosmikus DrSyzygy Skyp markovChain
    quicksilver viklund emma fadec maxote DarthMeh osfameron DustyDingo nemik juhp jml iratsu Nanar vegai Eelis fabjan boyscared levitation[A] mattam erg
    heavensrevenge 
*** Users on #haskell: m_stone daf dcoutts Wechner Japsu newt0n ksandstr kalven ahf mgregsond bmc_ mauke flori Apocalisp orbitz quuxman newsham felipe
    Nafai ziman agemo dionoea hesselink marmolak Giraffe wjt flux obraun wormcc stylus jmob cods Mitar sad0ur gdsx vincenz idnar MyCatVerbs tmoertel_away
    tote r0bby Laney Funjker_Boy22 ivan lilac regulate ski__ grul koninkje_away explicitjelly Vq^ jql And[y] Sartak DRMacIver mokus bockmabe Vulpyne
    Somni lispy inimino 
*** Users on #haskell: tmielika Draconx Choko dublpaws holzplatten admodum issal suiside Caelum thedward Jiten stevan tvaal chrisdone dons Pistahh C-Keen
    faXx sbok dcoutts_ Anthraxx miasma joed hellige chr1s shawn__ malouin Hunner thorkilnaur decklin ski_ gds Stephan202 MarcWeber IsoPallo_ Ornedan
    rodge nybyn rey_ qebab xmux integral znutar_ desp Arnar twifkak clog laz0r Spark tuukkah pcc1 bran_ ertai 
*** #haskell URL: http://www.haskell.org/  [11:51:43]
*** #haskell modes: +tncL  [11:52:06]
*** #haskell was created on ‘ÐÇ‘ÆÚ‘ÈÕ 2006/11/26 14‘Ê±42‘·Ö48‘Ãë
<wy> :t (>>=)  [11:52:08]
<lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
<hydo> Is there a way to regenerate package.conf.inplace?  [11:52:38]
<hydo> I don't supposed touch(1)'ing it would work ;)  [11:52:53]
<Cale> hydo: package.conf.inplace?  [11:53:47]
<mmorrow> hydo: hehe, why did you mess with it?  [11:54:01]
<Cale> (I know what package.conf is)  [11:54:15]
<mmorrow> (i'm not sure the answer other than rebuilding from scratch)  [11:54:41]
<hydo> I didn't touch it!  I promise! (heh) I installed ghc via macports ( on osx ) and now I'm trying to install gtk2hs but it's croaking on not being
       able to find that file.  [11:54:51]
<mmorrow> Cale: oh, package.conf.inplace is in the ghc src tree  [11:55:04]
<hydo> Ok, so it is an integral file which should be there.  [11:55:05]
<Cale> hydo: You should use the GHC binary.  [11:55:07]
<mmorrow> or at least, it's generated at some point during the build process  [11:55:20]
<hydo> Cale: ah, ha!  oks the .pkg from the ghc site?  [11:55:23]
<Cale> yeah  [11:55:32]
<hydo> Ok, on it!  Thanks again guys.  [11:55:40]
<Cale> I'm not certain about gtk2hss  [11:55:47]
<Cale> but you still should be using that binary :)  [11:55:55]
<mmorrow> hydo: oh, that means you're trying to invoke ghc directly and not with its shell script wrapper that passes it the correct - B option
                                                                                                                                                [11:56:02]
<mmorrow> -B  [11:56:06]
<hydo> oh  [11:56:15]
<mmorrow> this is what cat `which ghc` looks like on my sys:  [11:56:34]
<hydo> Well, macports was.  Either way, I'm gonna purge that package and install from the .pkg  [11:56:37]
<mmorrow> #!/bin/sh  [11:56:50]
<mmorrow> exec /usr/local/ghc/ghc-6.10.1/lib/ghc-6.10.1/ghc -B/usr/local/ghc/ghc-6.10.1/lib/ghc-6.10.1/e tdynload wrapped ${1+"$@"}  [11:56:51]
<mmorrow> yeah, macports i mean  [11:56:56]
<hydo> Cale/whoever: The first, and more official looking, one listed or the one "prepared by Christain Maeder" ?  [12:00:44]
<mmorrow> i'm not sure about the mac packages, but there are a bunch of mac users herei  [12:01:55]
* juhp stills thinks ghc-paths is bit silly currently anyway  [12:02:40]
<hydo> I'm grabbing the more official looking ones if the conventional wisdom says use the other one, welll, i'll download it too.. heh  [12:03:06]
<yuuki> Has anyone seen type combinators?  The idea is that any lambda expression can be represented by a combinator basis, and so I'm wondering if type
        products (pi-expressions) can be represented in the same way.  [12:11:39]
<luqui> yuuki, you mean as in dependent types?  [12:13:43]
<luqui> yuuki, i had a similar idea a while ago.  i suspect the answer is yes, but that it won't really help since it's not guaranteed unique (of course)
                                                                                                                                                [12:14:10]
<yuuki> Yes, but more generally any of the pure type system (PTS) systems  [12:14:16]
<yuuki> luqui, is it not unique?  [12:14:49]
<byorgey> actually, I don't see how that would work with a PTS.  [12:15:18]
<byorgey> Pi terms don't express any sort of computation, they justs are.  [12:15:35]
<luqui> yuuki, of course not.   otherwise every identity function would be SKK, and determining whether a function is the identity would be decidable
                                                                                                                                                [12:15:40]
<byorgey> they classify lambda expressions.  [12:15:50]
<yuuki> byorgey, but during abstraction pi-terms are reduced in the same way that lambda terms are, aren't they?  [12:15:58]
<luqui> byorgey, lambda terms don't express computation either  [12:16:16]
<yuuki> luqui, SKK should only have one type  [12:16:17]
<luqui> yuuki, huh?  [12:16:36]
<byorgey> yuuki: no, they aren't.  [12:16:50]
<byorgey> that's my point.  [12:16:53]
<luqui> yuuki, oh you're wondering whether combinator calculus can be *given* PTS types?  [12:17:01]
<byorgey> luqui: well, the reduction rules for application of lambdas then.  [12:17:10]
<luqui> not used in the representation?  [12:17:11]
<luqui> byorgey, there are such rules for pi terms  [12:17:20]
<yuuki> luqui, no, I'm wondering whether or not pi-terms can be represented using combinators  [12:17:32]
<byorgey> hm, I've never seen such rules  [12:17:35]
<byorgey> I've got to go to bed now but I'd be interested in discussing this more later =)  [12:17:54]
<yuuki> byorgey, yes, I'm pretty sure that the meaning of a pi-term is that it is reduced during beta-reduction to the body of the pi-term  [12:18:06]
<yuuki> luqui, I think SKK should only have one type, which is Pi x : a . a  [12:20:54]
<hydo> hahas holy crap.  All of that and I got the _exact_ same error.  "package.conf.inplace: openBinaryFile: does not exist"  looks like it's time to
       dig into gtk2hs's makefiles.  [12:21:42]
<luqui> yuuki, what about Pi x:a, id a ?
<luqui> or Pi x : a, s k k a ?  [12:21:56]
<hydo> make  [12:23:26]
<hydo> oops  [12:23:28]
<hydo> hh  [12:23:29]
<lpjhjdh> so I'm trying to build yi but I'm getting an error about Control.Category hidden in category-extras.  So I ghc-pkg expose category-extras and
          it still complains.  [12:25:27]
<dons> this review of RWH is awesome, http://www.amazon.com/review/RSLAPXI8MV0OB/ref=cm_cr_rdp_perm  "My guess is that this book will ignite the already
       growing haskell community. 10/10!". Woot. W're burning up!  [12:25:30]
<lpjhjdh> Am I doing something horribly wrong?  [12:25:35]
<dons> hmm.  [12:25:41]
<dons> oh, Control.Category is in base.  [12:25:49]
<lpjhjdh> oh, what is category-extras?  [12:26:14]
<yuuki> luqui, I think the type of (Pi x:a, id a) is *  [12:26:32]
<dons> a  big library of control structures  [12:26:36]
<luqui> yuuki, sure.  I'm saying the type of SKK could be Pi x:a, id a  [12:26:52]
<lpjhjdh> I see, thanks  [12:26:57]
<luqui> yuuki, which is the same as Pi x:a, a, but not decidably so  [12:27:05]
<yuuki> luqui, I don't think applications occur inside pi-terms?  [12:27:36]
<luqui> yuuki, then your calculus is very weak  [12:28:11]
<yuuki> luqui, oh I see  [12:29:04]
<yuuki> luqui, sorry, I am still trying to grok dependent types :)  [12:29:29]
<luqui> yuuki, sure.  they're very cool, but it takes a little stretch.  [12:29:49]
<yuuki> luqui, Pi x:a, id a should have a normal form  [12:30:05]
<luqui> I find them to be a lot more sensible than two-tiered systems like Hindley Milner in a lot of ways  [12:30:10]
<luqui> yuuki, well you hope it does.  [12:30:42]
<wy> polveroj: I found that I can't change newtype to type like "type StateMonad s a = s -> (a,s)". It doesn't allow me to apply StateMonad to only one
     argument. Is that the case for all type synonyms?  [12:30:45]
<yuuki> luqui, shouldn't we be able to find the normal form just like we can for lambda terms?  [12:30:59]
<luqui> yuuki, oh, that kind of normal form  [12:31:02]
<yuuki> luqui, for combinators, we should end up with only S's and K's that haven't met their reduction requirements  [12:31:38]
<luqui> yuuki, hmm.  I don't know if DT systems have confluent normal formss  [12:31:50]
<EvilTerran> wy, if you can eta-reduce the type to eliminate the parameter yourself, you can do that, and then apply that type synonym partially
                                                                                                                                                [12:32:06]
<yuuki> luqui, hmms I thought all of the lambda cube systems were strongly normalizing?  [12:32:23]
<EvilTerran> wy, for instance, "type List = []" instead of "type List a = [a]"  [12:32:28]
<mmorrow> the binary package has a nice test/ directory :)  [12:32:38]
<yuuki> luqui, another question of mine is, why do we need pi-terms and lambda-terms as separate concepts?  [12:32:47]
<luqui> yuuki, I don't know enough theory to answer that.  [12:32:54]
<luqui> yuuki, the lambda cube thing, that is  [12:33:02]
<luqui> yuuki, the difference between pi and lambda is something I stressed over for a while  [12:33:19]
<luqui> but the answer I came to iss because they're different  [12:33:28]
<wy> EvilTerran: In this case type StateMonad s a = s -> (a,s), it doesn't seem to be possible?  [12:33:52]
<yuuki> luqui, are they different?  [12:33:57]
<mmorrow> yuuki: i found this post interesting: http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html  [12:34:14]
<lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3  [12:34:16]
<EvilTerran> wy, indeed, you can't do that in this case  [12:34:19]
<luqui> yuuki, so if you have (t u), you're expecting t to be of the form \x. A, and the type of t to be Pi x. T  [12:34:35]
<wy> EvilTerran: So I have to use newtype here, because I need to apply it to one type argument  [12:34:42]
<mmorrow> he merges them there (or keeps them separate just for the sake of presentation, but makes it clear they need not be different concepts)
                                                                                                                                                [12:34:52]
<luqui> yuuki, but say the type of t were \x. T  [12:35:04]
<hydo> If anyone has a sec for a question, I think in this case it's better asked with an image.  re: building gtk2hs, http://snurl.com/77s73  [12:35:18]
<Philippa_> yuuki: I would imagine that you need a larger combinator base  [12:35:33]
<luqui> yuuki, (i'm completely winging it by the way, I remember just by thinking it through I came to an obvious conclusion, but I don't remember it)
                                                                                                                                                [12:35:35]
<mmorrow> yuuki: (while i'm sure you know, but just in case that post is by the author of cayenne)
*** Cale_ (n=Cale@CPE001c10c70239-CM000e5cdd834a.cpe.net.cable.rogers.com) is now known as Cale  [12:35:44]
<mmorrow> (and hbc)  [12:35:51]
<yuuki> mmorrow, I see.  I don't know about cayenne and hbc :)  [12:36:15]
<Philippa_> for approximately the same reasons that typed lambda calculi are bigger languagees than the untyped calculus  [12:36:16]
<hydo> Nevermind, answered my own question.  [12:36:57]
<mmorrow> yuuki: hbc was one of the first haskell compilers, and cayenne was one of the first compilers for a dependently typed lang  [12:37:02]
<mmorrow> http://www.cs.chalmers.se/~augustss/cayenne/  [12:37:04]
<luqui> yuuki, my brain is farting, actually, I can't come to the same conclusion again :-(  [12:37:07]
<lambdabot> Title: Cayenne  [12:37:10]
<mmorrow> err, cayenne was /the/ first compiler for h  [12:37:41]
<mmorrow> well, cayenne is a language, and its compiler was ^^^  [12:38:09]
<yuuki> mmorrow thanks!  [12:38:36]
<mmorrow> no problem :)  [12:38:44]
<shepheb> I installed 6.10, but my cabal-install is broken now. it can't resolve dependencies  [12:38:47]
<FunctorSalad> shepheb: memory leak when resolving deps? then you need to install the newest cabal-install  [12:40:03]
<shepheb> manually, I suppose  [12:40:17]
<mmorrow> heh, this is my favorite line from that blog post:  [12:40:24]
<mmorrow> type Type = Expr  [12:40:26]
<Philippa_> yuuki: you might want to read up on Pure Type Systems  [12:41:34]
<luqui> Philippa_, is that not what he(?) was talking about?  [12:41:57]
<yuuki> Philippa_, yeah, I've been reading that.  That's what brought on my question, why the need for both Pi and Lambda  [12:42:04]
<shepheb> okay, I just grabbed and built cabal-install. cabal mversion still shows Cabal 1.3 and cabal-install 0.4.9  [12:42:07]
<shepheb> path is correct, ghc is 6.10, ghc-pkg list Cabal shows 1.6  [12:42:24]
<b7j0c> hi! i have a question about a sort-of nontrivial piece of code: http://hpaste.org/12705  [12:42:39]
<b7j0c> my question is about how Error's propogate when connected with >>  [12:43:01]
<Philippa_> ah. To prevent an infinite progression of lambdas, I would've thought? The idea being that \s : pi ...  [12:43:47]
<b7j0c> in my function checkHeader in that hpaste, i have a series of functions that try to parse the header of an ogg file. but in the case of testing
        it with a non-ogg file, i get the Error from the *last* test in the sequence, not the first (where the failure would occur). why is that?
                                                                                                                                                [12:44:51]
<yuuki> That's one of the things that bothers me about type systems.   There are two levels, the evaluation level and then a level of propositions about
        the evaluation level  [12:45:04]
<yuuki> But in PTS, even types have types, so why does it matter?  [12:45:20]
<mmorrow> yuuki: there doesn't have to be  [12:45:25]
<Philippa_> actually, it's proofs of the propositions :-)  [12:45:33]
<luqui> yuuki, dependent type systems unify them, but in the opposite direction I thought they would
<luqui> yuuki, they unify them so that the bottom level is also propositions  [12:45:48]
<b7j0c> oh maybe i should just try a cafe list posth  [12:45:59]
<Philippa_> luqui: snot exactly  [12:46:07]
<yuuki> luqui, really?  could you give an example?  [12:46:11]
<luqui> b7j0c, i'm not sure about your code.  you know how the Either monad works?  [12:46:42]
<mmorrow> but a lang being dependently typed doesn't necessarily have to be one where expressions are required to be provably terminating  [12:46:54]
<Philippa_> rather, propositions can depend on it - but 1 isn't a type in its own right any more than Either is  [12:47:01]
<luqui> yuuki, what I meant by that was actually weaker than it sounded like.  I was referring to required termination proofs.  [12:47:14]
<yuuki> Hmm  [12:47:29]
<mmorrow> you could have one (e.g. cayenne) where you can do IO and write code that goes into an infinite loops just like you can do in haskell
                                                                                                                                                [12:47:31]
<luqui> mmorrow, true, but they usually are.
<yuuki> If the expression is well-typed, then that itself is a termination proof, isn't it?  [12:47:51]
<mmorrow> (which is good when you want to actually use that lang for real-world tasks)  [12:47:58]
<luqui> mmorrow, is it in a partiality monad or some such, or can the type checker get into an infinite loop?  [12:48:10]
<Philippa_> yuuki: normally that requires a more complex type  [12:48:16]
<luqui> yuuki, yeah.  proving that something is well typed can be pretty involved.  [12:48:27]
<mmorrow> luqui: the type checker can loop.  [12:48:40]
<luqui> mmorrow, hmm.  I might like to look at cayenne a bit.  [12:48:56]
<yuuki> luqui, hmms I thought that if you can construct it then it's well-typed  [12:49:12]
<mmorrow> luqui: it's great. i've been saying i'm gonna cabalize the code for forever now (but have yet to finish doing so ;)  [12:49:24]
<Cale> Heh, it would be funny to have a total language with a partial type system :)  [12:49:28]
<Cale> Once your program is compiled, you know it will terminate, but compilation might not :)  [12:50:09]
<mmorrow> luqui: here's a graphviz-rendered dep graph of the modules in the cayenne src http://code.haskell.org/~morrow/cayenne/cayenne.tred.png
                                                                                                                                                [12:50:14]
<Philippa_> yuuki: Sort of. Thing is, the version you construct to be well-typed in that setting is different  [12:50:23]
<mmorrow> and here are haddocks for (hierarchicalized by me) cayenne http://code.haskell.org/~morrow/cayenne/haddock/  [12:50:43]
<lambdabot> Title: cayenne-0.0: Cayenne  [12:50:44]
<Philippa_> same thing, but you're talking about it in different ways
<Philippa_> anyway: having two (or more) levels is what types are about, no?  [12:51:16]
<Philippa_> otherwise you just have tests ;-)  [12:51:17]
<mmorrow> i kept the same module structure as the code you'll get, but just stuck everything under Cayenne. so there'd be no conflicts with other
          packages  [12:51:20]
<yuuki> Philippa_, I think the ':' operator is what makes the difference.  x : a says that x is of type a.  [12:52:06]
<mmorrow> luqui: here's some TH code where i tried to follow exactly the method used in the cayenne code to do the same (printf)
          http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=484  [12:52:41]
<yuuki> Philippa, in PTSs, I think that only lambda-terms occur on the left and only pi-terms occur on the right  [12:52:45]
<Philippa_> right  [12:52:54]
<mmorrow> that printf code is from the cayenne paper (and is in test/)  [12:52:57]
<Philippa_> except that you will get lambdas inside the pis, and pis inside the lambdas  [12:54:23]
<mmorrow> Cale: heh, i wonder if such a thing could exist. (a total lang with a partial type system)  [12:54:33]
<mmorrow> i guess there's no reason why not?  [12:54:42]
<Philippa_> (\x:piv> ...) : ...  [12:54:55]
<Philippa_> etc  [12:54:58]
<EvilTerran> mmorrow, actually, it strikes me as being vaguely useful  [12:55:11]
<yuuki> Philippa, yes, but they are always on the left and right sides of : respectively  [12:55:12]
<dolio> Pis can occur on the left, too.  [12:55:14]
<mmorrow> EvilTerran: interesting. what's a use-case you see?  [12:55:37]
<yuuki> dolio, hmm, how so?
<EvilTerran> i'd rather my code fail to terminate at compile-time, when i'm there to fix it  [12:55:38]
<EvilTerran> than at run-time, when i may not be :)  [12:55:44]
<Philippa_> yuuki: pi s : []  [12:55:49]
<mmorrow> EvilTerran: ah, yeah i see where you're coming from.  [12:55:58]
<Philippa_> er, *->*  [12:56:01]
<dolio> Like (a -> b) : *. That's (Pi x:a b) : *  [12:56:30]
<yuuki> Ahh, good point.  [12:56:41]
<dolio> Assuming a and b are appropriate.  [12:56:44]
<dolio> And you can put lambdas on the right, too, although it's a little more contived.  [12:57:04]
<yuuki> dolio, I'm trying to figure out why Pi and Lambda aren't the same symbol  [12:57:17]
<dolio> Like (a -> b) : (\k -> k) *  [12:57:21]
<dolio> Which of course reduces to (a -> b) : *  [12:57:41]
<Philippa_> yuuki: you've just been shown why, really  [12:58:16]
<Philippa_> the pi-terms have their own sorts  [12:58:29]
<dolio> (\x:a -> e:b) : pi (x:a) b but pi (x:a) b : *  [12:58:56]
<dolio> Depending on what exactly a and b are, of course. It might be [].  [12:59:15]
<yuuki> isn't (\ k:* -> k) * the same as (Pi k:* -> *) *  [12:59:25]
<dolio> Or something in a tower of universes.  [12:59:28]
<yuuki> yikes.  Not sure if I stated that correctly  [13:00:05]
<dolio> Pis don't get applied to things.  [13:00:28]
<dolio> So '(Pi k:* -> *) *' isn't syntactically valid, even.  [13:00:45]
<yuuki> dolio, I think that anything on the left side of a ':' can be applied to something  [13:01:23]
<dolio> Or, it's certainly somehow disallowed.  [13:01:25]
<dolio> Ill typed, I suppose.  [13:01:44]
<hydo> Is there a repo viewer for darcs.haskell.org other than darcs.haskell.org/darcsweb ?  because it's pretty messed up.  [13:02:09]
<yuuki> any term t whose type is (Pi x:A . B) can be applied to term of type A  [13:02:37]
<dolio> The typing rule for application is 'f : Pi x:a e, y : a ==> f x : e[x/y]'  [13:02:52]
<yuuki> That was supposed to be (Pi x:A . B )
<dons> hydo: hmm. make a bug report about darcsweb plz  [13:02:56]
<dons> ?bug  [13:02:57]
<lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug  [13:02:58]
<dons> hydo: and igloo can update it.  [13:03:01]
<dons> hydo: normally i just use the web, then check out the src.  [13:03:11]
<dolio> But the type of 'Pi k:* *' is [] (I think that's right), not Pi x:a. b  [13:03:37]
<yuuki> Yes, so your claim amounts to the claim that no Pi term can have a type that is another pi term?  [13:03:41]
<yuuki> Because any pi-term whose type was a pi-term would be apply-able  [13:04:16]
<dolio> No Pi term does.  [13:04:22]
<dolio> The type of Pi x:A. B is given by whatever your axioms say it is given A and B.  [13:05:11]
<sjanssen> in the non-threaded RTS, are signal handlers executed during blocking foreign calls?  [13:05:21]
<Philippa_> which is required to be a sort, right?  [13:05:32]
<yuuki> dolio, dang, that's right.  [13:05:53]
<dolio> Yeah. It has to be a constant, I think.  [13:05:56]
<yuuki> dolio, it seems that the only purpose of typing for pi-terms is to restrain you from reusing them  [13:06:54]
<Philippa_> yuuki: how else do you keep things finite? If the type system gives lambdas other lambdas for types, checking never terminates because you
            spend forever building a tower of lambdas  [13:08:00]
<yuuki> dolio, isn't it odd that (Pi x : a . a) is of type * instead of some other type that reflects that pi-term's structure?  [13:08:06]
<mmorrow> heh  [13:08:20]
<mmorrow> @remember yuuki it seems that the only purpose of typing for pi-terms is to restrain you from reusing them  [13:08:34]
<lambdabot> Okay.
<sjanssen> ooh, the bug also manifests with gridselect!  [13:08:40]
<yuuki> mmorrow, haha, is that so odd?  [13:08:52]
<mmorrow> heh, i read that as s/reusing/using/ at first  [13:09:11]
<mmorrow> and didn't realize what it really said until after i @remembered it  [13:09:24]
<mmorrow> but still, it's funny to me :)  [13:09:32]
<yuuki> haha  [13:09:33]
<Philippa_> @remember mmorrow and didn't realize what it really said until after i @remembered it  [13:09:51]
<lambdabot> It is forever etched in my memory.  [13:09:52]
<mmorrow> hah  [13:09:59]
<Philippa_> had to be done :-)  [13:10:00]
<dolio> yuuki: I think I have to agree with Philippa_. I'm not sure type checking would terminate otherwise.  [13:10:10]
<yuuki> I dunno, types are supposed to be meaningful statements about expressions, but just blanketly saying that all pi-terms are of type * (or [])
        seems strange  [13:10:22]
<Philippa_> yuuki: that's not what's said though  [13:10:41]
<Philippa_> it's "all pi terms in which an A is bound within a B have sort C"  [13:10:57]
<dolio> Not all pi terms are *.  [13:11:00]
<yuuki> dolio, some are []  [13:11:11]
<Philippa_> some are wibble  [13:11:21]
<dmwit> Now now, let's not quibble.  [13:11:49]
<yuuki> right, hmm, maybe I can have an infinite set of sorts that curiously resemble lambda expressions :p  [13:11:54]
<dolio> And in a system with infinite universes, Pi a:SetN. b:SetM is Set(max(N+1,M)) or something like that.  [13:12:18]
<Philippa_> your sorts can be isomorphic to AxB, sure  [13:12:30]
<yuuki> Right right  [13:12:35]
<Philippa_> well, up to a point: you need a sort for As and a sort for Bs ands  [13:13:30]
<Philippa_> sthat's where * and [] /come from/  [13:13:45]
<yuuki> It is strange that the type of a term contains all of the information that can be reasoned about the term given the type system  [13:14:05]
<Philippa_> it doesn't  [13:14:29]
<luqui> dolio, but that's not necessary if you don't care about termination  [13:14:32]
<Philippa_> at least, not necessarily  [13:14:34]
<yuuki> It doesn't?  [13:14:37]
<yuuki> I think it does, for the systems where terms have only one type  [13:14:48]
<Philippa_> consider a PTS in which Int : * and Int : []s  [13:14:49]
<dolio> luqui: Sure. If we don't care about that, we can get rid of [] and say *:*.  [13:14:54]
<Philippa_> important condition :-)  [13:15:00]
<yuuki> Philippa, as far as I know, in the lambda cube every term has only one type  [13:15:19]
<Philippa_> sure. It's not true of PTSes in general  [13:15:35]
<yuuki> Barendregt is awesome  [13:17:09]
<dolio> Anyhow, I don't think it's necessarily more weird that Pi x:A. B has a type like * for a whole class of As and Bs than it is that 4, 5 and 6 all
        have type Int.  [13:17:31]
<yuuki> Hmm, it seems strange that 4, 5, and 6 have the same type  [13:18:32]
<yuuki> It seems like that keeps you from proving things about them  [13:18:44]
<dmwit> A type system where each type has only one inhabitant would be painful to use.  [13:19:25]
<yuuki> Well, types can be generalized, right?  [13:19:59]
<dolio> There is no type system, then, effectively.  [13:20:05]
<dmwit> Right, only a value system.  [13:20:24]
<dolio> There's only values, and every value has its own unique type.  [13:20:25]
<yuuki> You can have a function that will work on all integers without losing information about the integers themselves  [13:20:26]
<yuuki> dolio, well, \ x : a -> x would have the same type as \ y : a -> a  [13:21:27]
<yuuki> oops, \ y : a -> y  [13:21:40]
<dolio> That's the same value.  [13:21:47]
<dmwit> Those are the same value.  [13:21:48]
<dmwit> great minds, etc.  [13:21:56]
<Philippa_> yuuki: 4,5 and 6 having the same type doesn't prevent you proving things about them  [13:22:58]
<Philippa_> there are types that contain only (injections from) 4, 5 and 6  [13:23:16]
<yuuki> Hmms so there is a happy medium between having expressive types and having a type for each value?
<dmwit> You bet there is!  [13:23:33]
<dmwit> Finding that medium has been the subject of fifty years of research.  [13:23:41]
<dmwit> Personally, HM-typing is my current favorite for the happy medium. =)  [13:24:17]
<dmwit> haskell++  [13:24:19]
<Philippa_> the obvious one would be the type of a pair containing an int x and the sum of proofs that x is 4, 5 and 6 respectively  [13:24:27]
<dolio> Incidentally, from what I've read of (I think) Dependent ML, they actually have types that contain only, say, 6.  [13:24:34]
<yuuki> dmwit, what is HM?  [13:24:44]
<luqui> HM is very useful.  but it does not adequately satisfy my desire for awesomeness  [13:24:48]
<dolio> And then integers in general are an existential quantification over all such types.  [13:24:52]
<dmwit> yuuki: Hindly-Milner; it's the type system Haskell uses.  [13:25:01]
<yuuki> I thought HM was just the inference algorithm
<lament> dmwit: by HM you of course mean "with all the extensions"?  [13:25:05]
<dmwit> might be  [13:25:07]
<markovChain>   [13:25:09]
<dmwit> lament: Naturally. ;-)  [13:25:18]
<Philippa_> yuuki: no, the inference algorithm is an implementation of the H-M type system  [13:25:27]
<Philippa_> (Haskell's type system is actually a fairly large extension of it)  [13:25:39]
<dmwit> luqui: Well, dependent types are very nearly the last word in awesomeness.  But they are not a happy medium.  [13:25:41]
<dmwit> Type inference goes a really long way.  [13:25:46]
<dolio> But that's, I think, because they tried as hard as possible to keep a phase distinction between compile-time types and runtime values.  [13:25:47]
<dmwit> Having principle types is pretty nice, too.  [13:25:59]
<yuuki> Are you sure there is a H-M type system?  [13:26:17]
<Philippa_> yuuki: totally. Go read up already  [13:26:26]
<yuuki> Last time I read about it, H-M was the name of a type inference algorithm for systems in the lambda cube  [13:26:48]
<Philippa_> you're wrong  [13:26:58]
<dolio> It definitely can't infer types for everything in the lambda cube.  [13:27:10]
<dmwit> Nothing can!  [13:27:17]
<dolio> :)  [13:27:20]
<adu> what's a lambda cube?  [13:27:28]
<yuuki> Philippa, try googling about it  [13:27:32]
<Philippa_> H-M does rank-1 parametric polymorphism  [13:27:36]
<dmwit> ?go time cube
<lambdabot> http://www.timecube.com/  [13:27:39]
<lambdabot> Title: Time Cube
<Philippa_> yuuki: I don't need to  [13:27:41]
<yuuki> Philippa, you won't see anything about a Hindley  [13:27:48]
<dmwit> adu: It's a way of parameterizing several interesting languages.  [13:27:55]
<yuuki> Hindley-Milner system, you'll just see references to the algorithm  [13:27:59]
<adu> dmwit: are you into obscurantism?  [13:28:25]
<yuuki> Philippa, I think System F is the type system you're talking about  [13:28:36]
<dmwit> adu: In Haskell, you have terms that depend on terms, right?  These are called functions.  [13:28:37]
<Philippa_> yuuki: no, it's not  [13:28:45]
<Philippa_> kindly stop patronising me  [13:28:50]
<dmwit> adu: Sorry for the obscurity, I'm still typing. =)  [13:28:51]
<Philippa_> System F is /not/ the H-M system at all - it's rank-n, and has type annotations  [13:29:07]
<yuuki> Philippa, s I'm not trying to patronize you, I'm trying to understand what you're talking about  [13:29:14]
<yuuki> System Fw is the rank-n System F  [13:29:25]
<Philippa_> you're doing it by telling me I'm wrong. This is rude  [13:29:28]
<Philippa_> no, it's not  [13:29:31]
<dmwit> adu: So, you could also imagine terms depending on types, types depending on types (polymorphism), and terms depending on types (dependent
        typing).  [13:29:35]
<dmwit> adu: And, it turns out you can have these features independently, so they can act as axes.  [13:29:56]
<Philippa_> hint: w isn't a natural number
<yuuki> Philippa, http://en.wikipedia.org/wiki/Type_inference#Hindley.E2.80.93Milner_type_inference_algorithm  [13:30:25]
<lambdabot> Title: Type inference - Wikipedia, the free encyclopedia, http://tinyurl.com/72ovj  [13:30:27]
<dolio> System Fw allows variables to quantify over order-n type functions.  [13:30:30]
<dmwit> adu: Since there are three "axes" (languages without the term-depending-on-term axis aren't so interesting), they call it a cube.  [13:30:33]
<Philippa_> yuuki: yes. There is an inference algorithm that was provided to go /with/ the type system  [13:30:47]
<Philippa_> but there is also a type system. The relationship's pretty close, of course  [13:31:00]
<yuuki> Philippa, do you know of any resource that mentions the Hindley-Milner type system?  [13:31:19]
* dmwit wonders briefly if this argument is worth winning for either side  [13:31:28]
<Philippa_> consider that the simply-typed lambda calculus /is/ its inference algorithm  [13:31:30]
<Philippa_> TaPL  [13:31:35]
<Philippa_> consider for a moment: there /has/ to be such a type system, merely filling in annotations for the lambdas doesn't give you a System F term
                                                                                                                                                [13:32:36]
<Philippa_> nor is the simply-typed lambda calculus enough  [13:33:07]
<edwardk> @seen luqui  [13:33:58]
<lambdabot> luqui is in #haskell. I last heard luqui speak 9m 11s ago.  [13:33:59]
<Philippa_> also, if you're that worried try googling "hindley-milner type system"  [13:34:14]
<edwardk> @seen conal  [13:34:20]
<lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.  [13:34:21]
<conal> edwardk: here  [13:34:25]
<edwardk> hey i made some progress tackling behaviors and futures categorically  [13:34:46]
<conal> cool!  [13:34:59]
<yuuki> Philippa, sorry for bugging you :)  I found some resources that mention it as a type system  [13:35:28]
* Philippa_ nods and sighs  [13:35:36]
<Philippa_> I guess you weren't to know that I've spent a lot of the last year working on a very close relative  [13:35:53]
<edwardk> type Future = (,) Time; type B = (->) Time, type Behavior = Density B a m Density B a is isomorphic to B a  [13:36:18]
<Philippa_> (close enough that some people would simply consider the inference system/algorithm to /be/ Hindley-Milner)  [13:36:44]
<edwardk> now, (,) Time is left adjoint to (->) Time which is isomorphic to my Behavior type, so we can now abuse that adjunction  [13:36:53]
<pumpkin> I'm just reading up on functors and fmap in RWH and was wondering what can be done about the "no constraints" issues is it not considered to be
          an issue, or are there proposals to alleviate it? I can envision wanting to fmap over a set, but even if set didn't require ord, it would
          definitely require eq  [13:37:04]
<edwardk> the unit of the adjunction: unit :: a -> Behavior (Future a) returns a behavior that returns a future at that moment of time it is queried with
          the value supplied.  [13:37:43]
<Cale> pumpkin: The problem is essentially that the Functor typeclass doesn't express what it means to be a Functor in general, only what it means to be
       an endofunctor on the category Hask of Haskell types and functions.  [13:37:56]
<adu> dmwit: I thought dependent typing was types depending on termss?  [13:38:01]
<edwardk> the counit:: Future (Behavior a) -> a takes a future behavior and applies that behavior as it will be at the time of the future.  [13:38:18]
<Cale> pumpkin: Set is a functor on a different category, specifically, the subcategory of Hask which consists of types in Ord.  [13:38:33]
<conal> edwardk: i don't have the focus right now to take in what you're saying.  would you mind emailing it to me?  i can also then learn the concepts
        i'm missing as i read it.  [13:39:07]
<edwardk> leftAdjunct and rightAdjunct have meanings in terms of transforming functions that work with Futures into ones that work on behaviors and vice
          versa. leftAdjunct :: (Future a -> b) -> a -> Behavior b, and vice versa for rightAdjunct  [13:39:12]
<dmwit> adu: You're right, of course, terms depending on types is what you get in languages like LF.  [13:39:21]
<edwardk> my definition for Zap also works immediately there, as it is a superclass of Adjunction zap :: Behavior (a -> b) -> Future a -> b or zap ::
          Future (a -> b) -> Behavior a -> b  [13:39:58]
<adu> dmwit: what is LF?  [13:40:03]
<dmwit> "logical framework"  [13:40:11]
<pumpkin> Cale: interestings so are there proposals on making fmap more general, or does the language not support that kind of generality?  [13:40:22]
<conal> edwardk: also, if you'll review & apply that category-extras patch i sent you, then people can run the code i'm attaching to my next blog post.
                                                                                                                                                [13:40:24]
<edwardk> at = lowerDensity  [13:40:26]
<dmwit> It's kind of neat, but I've never had enough time to really try it out and understand it.  [13:40:27]
<dmwit> ?go twelf  [13:40:31]
<lambdabot> http://twelf.plparty.org/  [13:40:43]
<lambdabot> Title: The Twelf Tutorial, January 19 2009, Savannah, GA
<FunctorSalad> pumpkin: it's been done, see rmonad  [13:41:07]
<adu> dmwit: but the Vec type, isn't that deptypes?  [13:41:10]
<FunctorSalad> @where rmonad  [13:41:11]
<lambdabot> I know nothing about rmonad.
<pumpkin> looking now :)  [13:41:19]
<FunctorSalad> @google haskell rmonad  [13:41:20]
<lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad  [13:41:26]
<lambdabot> Title: HackageDB: rmonad-0.3
<pumpkin> FunctorSalad: found it, thanks  [13:41:27]
<FunctorSalad> :)  [13:41:31]
<adu> dmwit: like Vec ::  Nat -> Type -> Type  [13:41:35]
<dmwit> I'm not sure I know what you're talking about now.  [13:41:37]
<dmwit> ah  [13:41:45]
<Cale> pumpkin: There are tricks you can do to make fmap work more generally, but they're somewhat ugly.  [13:41:47]
<edwardk> conal: and then the last couple of bits are that you can derive the state monad and context comonad parameterized by Time from the definitions
          for Behavior and Future above.  [13:42:01]
<adu> dmwit: its the most common example of a type you can't express (nicely) in Haskell  [13:42:08]
<dmwit> yep  [13:42:18]
<edwardk> conal: i will, but i left the VM that I have the category-extras code on at work ;)  [13:42:28]
<adu> dmwit: and isn't that an example of types depending on terms?  [13:42:48]
<Cale> pumpkin: The language of the future will probably have more direct support for categorical ideas :)  [13:42:50]
<pumpkin> yay  [13:42:57]
<edwardk> (it also has all the code for my current obsessions on it, hence why i got bored and started hacking on FRP today) ;)  [13:43:06]
<pumpkin> are things like haskell' or 2 already working towards that, or is it way in the future?  [13:43:15]
<dmwit> adu: syes?  [13:43:24]
<dmwit> I'm not sure where you're going with this.  [13:43:31]
<Cale> Haskell' is rather conservative. There's not currently a concerted Haskell 2 effort.  [13:43:43]
<FunctorSalad> by the way, why don't we just give every value a hash, so everything has an Eq and Ord instance that is suitable for things like Set
                                                                                                                                                [13:43:48]
<conal> edwardk: thx.  would you email me your frp-related remarks.  i'll be able to take them in better later.  [13:43:52]
<adu> dmwit: where I'm going with this, is I was trying to dislodge your definition of "dependant types" as terms depending on typess  [13:44:09]
<edwardk> conal: i'm trying to see if i can mush them into a blog post as we speak  [13:44:13]
<dmwit> adu: I already admitted that was wrong.  [13:44:18]
<adu> oh ok :)  [13:44:23]
<Cale> FunctorSalad: In those cases, using Map is probably a better idea.  [13:44:33]
<dmwit> adu: I got dependent types and LF's extra stuff mixed up (again).  [13:44:39]
<jberg> what module do i have to load from ghci to use sort?  [13:45:35]
<Cale> jberg: Data.List  [13:45:43]
<jberg> thanks  [13:46:03]
<FunctorSalad> Cale: I meant the cases where Ord ist just used to build an internal tree for efficiency, e.g. Set and Map  [13:46:20]
<Cale> FunctorSalad: Things which ought to be considered equal might hash to different things, and vice versa.  [13:46:38]
<Cale> (things which ought to be considered different might hash to the same thing, unless these hashes are unbounded in size)  [13:47:06]
<FunctorSalad> Cale: yes, it doesn't solve the "a set can contain only one member from each Eq class"  [13:47:12]
<FunctorSalad> but the internal efficieny thing  [13:47:22]
<Cale> Usually it suffices to make up your own IDs and tag things with them.  [13:48:02]
<FunctorSalad> I just proposed this to get rid of the Ord constraint for Set :)  [13:49:14]
<pumpkin> what do people think of the haskell school of expression btw? (I'm reading RWH, but my gf's course is using SOE and I was curious)  [13:49:26]
<FunctorSalad> with Set you usually don't care about the ordering, you just need to have one  [13:49:36]
<Cale> It would be interesting to have a total (or even well) ordering on every type, but I think it's not computably realisable :)  [13:49:39]
<FunctorSalad> Cale: if the current hashing algorithms are as random as we think they are, you should worry about cosmic rays before you worry about hash
               collisions ;)  [13:50:14]
<FunctorSalad> (AFAIK)  [13:51:34]
<orbitz> what is SOE?  [13:52:06]
<Cale> orbitz: School of Expression  [13:52:14]
<pumpkin> haskell school of expression  [13:52:15]
<Cale> orbitz: It's a book about Haskell.  [13:52:19]
<orbitz> k  [13:52:28]
<Cale> (and well, functional programming in general)  [13:52:33]
<conal> edwardk: question about (possibly empty) lists: i know extact is partial.  does a comonad law fail?  [13:52:37]
<luqui> Cale, of course not.  function types, follows from rice :-)  [13:53:14]
<Cale> conal: Possibly empty lists aren't a comonad, are they?  [13:53:25]
<conal> i don't know  [13:53:35]
<luqui> no  [13:53:42]
<conal> what fails?  [13:53:48]
<luqui> they are not copointed  [13:53:52]
<conal> why not?  [13:53:59]
<FunctorSalad> luqui: you could hash (whatever representation the function has in memory)  [13:54:03]
<luqui> f a -> a,  where are you going to get the a?  [13:54:08]
<conal> bottom  [13:54:13]
<luqui> oh!  okay we have to find the law that violates I guess.  [13:54:26]
<edwardk> conal: one could argue that the segments you are defining aren't comonadic, unless you always allow them to be queried at time 0  [13:54:27]
<conal> edwardk: i do allow them.  [13:54:45]
<luqui> FunctorSalad, but that wouldn't be extensionally stable  [13:54:50]
<conal> edwardk: when they're empty, they return bottom at time 0.  [13:55:02]
<conal> extract exists.  does a law fail?  [13:55:12]
<edwardk> conal: then you have a hole in your semantics. you could argue that they'll never get queried through some sort of meta reasoning that perhaps
          would suffice  [13:55:14]
<conal> edwardk: i'm trying to ask an objective question.  [13:55:32]
<conal> edwardk: what fails?  [13:55:41]
<FunctorSalad> luqui: as in "equal functions hash to equal things"? right, but that hash should only be used for efficiency reasons, not for anything
               semantically important  [13:55:46]
<edwardk> you have a partial extract?  [13:55:47]
<conal> edwardk: what shape of hole?  [13:55:51]
<conal> edwardk: yes.  [13:55:56]
<FunctorSalad> luqui: (as in Set)  [13:56:01]
<luqui> FunctorSalad, so it can't be used as a well ordering  [13:56:06]
<edwardk> whenever you have a comonad you need to be able to extract and get a value. injecting undefined to fill the value isn't really satisfying the
          spirit of the law ;)  [13:56:23]
<luqui> or, I missed the context of the discussion.  [13:56:28]
<conal> edwardk: i'm not boasting about the partiality.  i want to know exactly what fails.  [13:56:49]
<edwardk> as for particular laws what is the result of extend extract?  [13:56:57]
<pumpkin> well I think the point was for things like set, you don't need an ordering, so even if a hash would give a meaningless ordering, you don't care
                                                                                                                                                [13:57:04]
<FunctorSalad> luqui: the context was that I find the Ord context for Data.Set slightly questionable  [13:57:16]
<edwardk> extend extract = id should hold  [13:57:19]
<edwardk> that is what i'm worried about  [13:57:25]
<Cale> What's duplicate [] ?  [13:57:32]
<FunctorSalad> luqui: since the actual ordering doesn't matter for the semantics of Set  [13:57:33]
<pumpkin> Data.Set would still need Eq, and that could resolve issues with collisions (however unlikely)  [13:57:39]
<conal> Cale: [[]]  [13:57:40]
<conal> edwardk: that's more like what i'm looking.  thx.  [13:57:50]
<FunctorSalad> pumpkin: right  [13:57:54]
<Cale> Then (fmap extract . duplicate) is not the identity.  [13:58:24]
<conal> i can avoid this problem by removing Copointed as a parent of Comonad.  [13:58:36]
<conal> i don't think i need copointed  [13:58:56]
<pumpkin> FunctorSalad: I like that idea better than the current implementation :P same for map  [13:58:57]
<conal> just happens to be bundled.  [13:58:59]
<edwardk> which you get from C.F.C's CExtendable  [13:59:24]
<conal> edwardk: yes.  [13:59:34]
<FunctorSalad> pumpkin: hmms on the other hand, if you put some function f into a set and later look up an function f' = f, but f' has a different hash
               now due to different representation... won't the lookup fail?  [14:00:26]
<luqui> FunctorSalad, Set.fromList [id, id.id, succ]   m how many elements / Set.elem (id.id.id) s ?  [14:00:40]
<FunctorSalad> (@ luqui too)
<luqui> yeah that is what I just conjectureds  [14:00:57]
<edwardk> i just realized i seem to be heading in a slightly different direction towards how to represent time, while you seem to be moving to purely
          relative time, with 0 as now, i'm sitting here trying to abuse the context comonad, because the adjunction scenario mentioned before seems to
          suggest it  [14:01:02]
<pumpkin> FunctorSalad: it depends how you define the hash, I guess  [14:01:22]
<FunctorSalad> pumpkin: as luqui pointed out, there is no way to hash functions such that extensionally equal functions will hash to the same value
                                                                                                                                                [14:02:02]
<mmorrow> edwardk: the typesyns in category-extras prompted rwbarton and i to each write a typesyn eliminator (w/ TH) (not to suggest anything of course
          ;):  [14:02:03]
<mmorrow> , (ppDoc . elimSyns) `fmap` [t|Cofree (Coideal Maybe) Int|]  [14:02:12]
<edwardk> that would make something a bit like what luke suggested earlier, but instead of a * (Time -> a) or some variation thereof, it'd be the context
          comonad (Time, Time -> a), which can be queried for that time, or for points in the future of it by adding offsets  [14:02:14]
<lunabot>  Fix (Biff (,) Identity (Lift_ (,) Identity Maybe)) Int  [14:02:18]
<edwardk> mmorrow: i realize they are horrific ;)  [14:02:29]
<luqui> FunctorSalad, of course there is!
<luqui> const 0  [14:02:30]
<pumpkin> FunctorSalad: there's a way to order them though?  [14:02:36]
<mmorrow> (i had to add the _ to Lift on account of Lift being in TH and the ghc-api not doing qualified imports easily)  [14:02:45]
<Cale> (fmap extract . duplicate) [] = fmap extract [[]] = [extract []] = [undefined]  [14:02:59]
<mmorrow> edwardk: i love the Mutual type  [14:03:12]
<mmorrow> , src ''Mutual  [14:03:18]
<FunctorSalad> luqui: ;)  [14:03:20]
<edwardk> mmorrow: thanks, that one hurt my brain =)  [14:03:23]
<lunabot>  newtype Mutual p m n a = Mutual {runMutual :: (m (p a  [14:03:24]
<lunabot>                                                      (Mutual p n m a)))}
<mmorrow> heh  [14:03:29]
<FunctorSalad> pumpkin: hmm, I don't think that's possible either  [14:03:50]
<mmorrow> it made me think to write this function:
<edwardk> mmorrow: but i needed it for coideal comonad products and ideal monad coproducts iirc  [14:03:51]
<pumpkin> FunctorSalad: so in that case, your proposal isn't really losing much against the current situation  [14:04:06]
<mmorrow> mutual :: (a -> (b -> s) -> r) -> (b -> (a -> r) -> s) -> a -> r  [14:04:15]
<mmorrow> mutual f g a = f a (\b -> mutual g f b)  [14:04:16]
<mmorrow> and with it you can do:  [14:04:24]
<mmorrow> unfoldr f = mutual (\a k -> (k . f) a)  [14:04:33]
<mmorrow>                    (\m k -> maybe [] (\(b,a) -> b : k a) m)
<pumpkin> we can't make meaningful sets of functions, but we can remove the (seemingly) unnecessary requiement of Ord and go for the more relaxed Eq
          (maybe?) :P  [14:04:37]
<dmwit> Eq is hard on functions.  [14:04:58]
<edwardk> luqui: how do you feel about say, something like (Time, Time -> a) w.r.t our earlier discussion?  [14:05:07]
<pumpkin> yeah
<dmwit> It's the No Free Lunch theorem for compilers.  [14:05:14]
<pumpkin> :)  [14:05:19]
<luqui> actually, it's worse than Hard (capital H)  [14:05:20]
<pumpkin> yup  [14:05:29]
<mmorrow> edwardk: (and i wasn't being sarcastic about Mutual ;)  [14:05:32]
<FunctorSalad> luqui: how would you complete the requirement for the hash then? ;) clearly we can't have "extensionally different functions have
               different hashes"  [14:06:07]
<edwardk> mmorrow: i'm glad, coz i really do think i sprained something in my brainpan trying to figure out the coideal product stuff ;)  [14:06:09]
<FunctorSalad> luqui: but maybe something about "no more collisions than expected by chance"  [14:06:28]
<mmorrow> edwardk: heh, i've definitely sprained something in my brainspan as well trying to think of some i'm sure sweet ways to make use of it
                                                                                                                                                [14:06:55]
<luqui> edwardk, yeah, that is a very nice one that i would like quite a lot.  can it be implemented efficiently?  [14:07:00]
<luqui> FunctorSalad, defining chance, etc.  [14:07:43]
*** zeno__ (n=andrew@71-221-102-121.clsp.qwest.net) is now known as zeno  [14:07:50]
<luqui> I would say const 0 meets the requirements for a hash function  [14:07:56]
<luqui> it's just a poor choice from an efficiency standpoint  [14:08:02]
<pumpkin> but you can't stick functions into sets right now, right, because they aren't Ord?  [14:08:08]
<luqui> pumpkin, yeap.  [14:08:20]
<edwardk> luqui: that is just the context comonad, so it permits all the usual tweaks, layering Density or Coyoneda over any of the parts of it that
          happen to be comonadic, etc. to fix leaks or time.  [14:08:22]
<luqui> pumpkin, you could manage certain functions; eg. Bool -> Bool can be massaged to go into a Set  [14:08:38]
<pumpkin> how?  [14:08:53]
<luqui> edwardk, s   h  5   !!  [14:08:57]
<luqui> edwardk, I really need to read about this stuff  [14:09:04]
<edwardk> well, i don't know that anyone has written it up, thats why i figured i should tackle this as something practical to throw all of this crap at
                                                                                                                                                [14:09:32]
<pumpkin> luqui: oh I see  [14:09:35]
<pumpkin> :P  [14:09:36]
<luqui> edwardk, yes yes yes!  [14:10:29]
<luqui> I am amazingly intrigued.  [14:10:41]
<pumpkin> so change Set to need (Hashable a) instead of (Ord a) :P  [14:10:45]
<luqui> maybe finally this is motivation for me to seriously consider category theory  (I have only seen it on the surface)  [14:11:11]
<pumpkin> except for things that are already Ord, it would use that :o  [14:11:13]
<luqui> or maybe haskelegory theory  [14:11:24]
<FunctorSalad> good name  [14:11:43]
<edwardk> luqui: technically i'm not looking at (Time, Time -> a) but instead ACompF Future Behavior a rather than ACompF Future B a where Behavior =
          Density B, where B = (->) Time, which would contort that first expression a bit  [14:11:58]
<mmorrow> pumpkin: however, you could use System.Mem.StableName to get a StableName for functions, then hashStableName to get an Int which you /can/ put
          in a Set  [14:12:07]
<mmorrow> (i haven't tried that exactly, but i've experimented with System.Mem.* a bit)  [14:12:25]
<pumpkin> mmorrow: but it wouldn't be a useful representation  [14:12:35]
<mmorrow> looks like one could do cool things with it  [14:12:44]
<luqui> edwardk, right I read about your adjunctions  [14:12:47]
<mmorrow> pumpkin: why?  [14:12:49]
<mmorrow> do you actually care what the ordering is, rather than that you just have /any/ ordering?  [14:13:17]
<edwardk> which appears to contort that first example into something like forall b. Behavior Time (Time -> b) ((Time -> b) -> a)  [14:14:03]
<mmorrow> it'll essentially give you a ptr to the function itself  [14:14:05]
<pumpkin> mmorrow: well the stable name would mean that f == f, not that if g had the same definition as f, it would be equal to f, right?  [14:14:15]
<jberg> can i access values from a scope higher up from a where clause?  [14:14:16]
<edwardk> which is a little weird  [14:14:17]
<dmwit> jberg: certainly  [14:14:27]
<jberg> ok cool  [14:14:33]
<mmorrow> pumpkin: well, if g realy /is/ f, then they'll have the same stable name  [14:14:37]
<pumpkin> mmorrow: and definitely not if g represented the same mapping, but had a different definition right?  [14:14:42]
<mmorrow> correct  [14:14:52]
<pumpkin> hmm  [14:15:15]
<mmorrow> so yeah, i see your use-case now  [14:15:17]
<luqui> edwardk, i can't really tell how that would work operationally  [14:15:22]
<pumpkin> I mean, I don't particularly care about adding functions to sets  [14:15:27]
<pumpkin> but it seems tough if you do :P  [14:15:38]
<mmorrow> or maybe i don'ts but either way what you just described may be a problem if one cares about that in particular  [14:15:45]
<pumpkin> maybe just functions on finite domains for now  [14:15:46]
<edwardk> luqui: well, if we unlayer it abit, it may make more sense.  [14:16:01]
<mmorrow> i like using Map for such functions  [14:16:11]
<pumpkin> then you can store them in a Map  [14:16:27]
<pumpkin> or a Set  [14:16:38]
<mmorrow> because then you can do with such "functions" what you can do with functions in math  [14:16:39]
<pumpkin> yeah  [14:16:41]
<pumpkin> hmm  [14:16:47]
<mmorrow> but unfortunately the domain/range must be finite :(  [14:17:20]
<mmorrow> (obviously)  [14:17:26]
<luqui> edwardk, does any of this efficiently capture monotonicity?  [14:17:27]
<edwardk> peeling back to just Density B a, we get something values that look like exists b. Density ((Time -> b) -> a) (Time -> b) instead of Time -> a
                                                                                                                                                [14:17:32]
<pumpkin> yup  [14:17:36]
<edwardk> yeah, because the monoid on Time  [14:17:40]
<luqui> so Time would be something clever?  [14:17:52]
<luqui> rather than a number  [14:17:55]
<edwardk> you have a 'current moment in time' and you can 'add to it' but i don't have to give you anything else  [14:17:57]
<pumpkin> mmorrow: I guess you could also work with functions equivalent to DFAs on infinite inputs  [14:18:22]
<pumpkin> that output booleans  [14:18:31]
<mmorrow> pumpkin: hmm, interesting.  [14:18:37]
<luqui> pumpkin, Stream Bool -> Bool  has decidable equality :-)  [14:18:52]
<pumpkin> I don't know what Stream is :o  [14:19:08]
<luqui> it's an infinite list.  Data Stream a = Stream a (Stream a)  [14:19:21]
<mmorrow> i'm not exactly cure what that means yet, but would one be able to e.g. take the intersection of the images of two such functions?  [14:19:22]
<pumpkin> but I'm assuming it's related to what I just said? :P
<pumpkin> ah  [14:19:24]
<mmorrow> (assuming  f : A -> C   g : B -> C)  [14:19:36]
<mmorrow> s/sure/cure/  [14:19:49]
<mmorrow> gah  [14:19:51]
<mmorrow> s/cure/sure/  [14:19:55]
<mmorrow> i guess not on account of the domain being infinites  [14:20:42]
<edwardk> luqui: its not perfect because the design above doesn't prevent you from extracting the function and calling it with an earlier time  [14:21:09]
<luqui> hmm, so there would be a necessary inefficiency there if it were correct  [14:21:31]
<edwardk> you could tweak it a bit with some quantification games
<mmorrow> \f g -> Map.elems f `intersect` Map.elems g  [14:21:48]
<edwardk> you could make something like forall b. (Time b, Time b -> a) m and quantify over b or something in a way that kept them from giving you
          another Time object without having obtained it from you first.  [14:22:24]
<edwardk> then you could write a function that took a delta and 'wound' the clock by that much gtiving you one back with the same type parameter
                                                                                                                                                [14:22:44]
<edwardk> since it comes out of the box with an existential no one could give you one without cheating and using unsafeCoerce  [14:23:11]
<mmorrow> unsafeCoerce: the ninja weapon of choice  [14:23:37]
<edwardk> then its not the context comonad for Time, its the density comonad of that special 'keyed Time' functor  [14:23:55]
<mmorrow> oh hah, speaking of unsafeCoerce, i picked unsafecoerce.{com,org,info,net} the other week  [14:24:31]
<mmorrow> score!  [14:24:34]
<edwardk> nice  [14:24:43]
<luqui> edwardk, keyed time is something I've played with, but in a pretty different capacity  [14:25:05]
<mmorrow> unsafeperformio.com gave me the idea, and when i did a whois was stunned that no one had it  [14:25:23]
<luqui> edwardk, Time was a connection between time on the type level and on the value level.  So there were functions like transitive :; t :< t' -> t'
        :< t'' -> Time t -> Time t'  [14:25:45]
<luqui> er Time t''  [14:25:48]
<mmorrow> hpaste2 is also reachable via: unsafecoerce.com:8080  [14:26:15]
<edwardk> hrmm  [14:26:16]
<sjanssen> hi, can someone with GHC 6.10 on x86-64 tell me the output of "sizeOf True"?  [14:26:21]
<sjanssen> you'll need to load the Foreign.Storable module first  [14:26:32]
<mmorrow> > sizeOf True  [14:26:44]
<lambdabot>   Not in scope: `sizeOf'  [14:26:45]
<mmorrow> dang  [14:26:48]
<sjanssen> mmorrow: the bot doesn't import Foreign.* because it is unsafe  [14:26:58]
<mmorrow> , maxBound :: Int  [14:26:59]
<lunabot>  2147483647  [14:27:02]
<mmorrow> sjanssen: figured it was worth a shot ;)  [14:27:14]
<roconnor> , fix bitSize  [14:27:24]
<lunabot>  32  [14:27:26]
<sjanssen> I specifically need to know if Bool is considered 4 or 8 bytes on GHC > 6.8.x  [14:27:28]
<mmorrow> wuh, where is bitSize from?  [14:27:43]
<sjanssen> it is 4 on 6.8.3  [14:27:50]
<Cale> mmorrow: Data.Bits  [14:27:56]
<mmorrow> ahhh, hmm  [14:28:05]
<mmorrow> never noticed that one before  [14:28:11]
<lpjhjdh> Prelude Foreign> sizeOf True = 4  [14:28:57]
<lpjhjdh> on amd64 with 6.10.1  [14:29:12]
<sjanssen> lpjhjdh++ thanks for your help  [14:29:34]
* sjanssen is back to the drawing board  [14:29:43]
<pumpkin> can someone explain the basic idea of a constant-access-time array in FP?  [14:31:08]
<roconnor> pumpkin: easy.  Impertive programs don't have constant-access-time arrays  [14:31:42]
<pumpkin> hmm?  [14:32:05]
<QtPlatyp1s> roconnor: Yes they do.  [14:32:13]
<roconnor> because arrays have a fixed size limit  [14:32:16]
<Cale> pumpkin: What do you want explained? They're just normal immutable arrays.  [14:32:20]
<edwardk> luqui: well i have the 8 line implementation of the keyed clock idea more or less  [14:32:30]
<edwardk> @hpaste  [14:32:33]
<lambdabot> Haskell pastebin: http://hpaste.org/new
<roconnor> so complexity is meaningless
<Cale> But constant access time is a bit of a lie.  [14:32:36]
<roconnor> or  [14:32:56]
<Cale> As the array grows, you incur at least log time. It's just that it's usually a cost which is hidden from you at the hardware level.  [14:33:04]
<roconnor> arrays in impertive code can be arbitarily big  [14:33:07]
<roconnor> and hence they cannot be constant time access  [14:33:16]
<pumpkin> Cale: I mean, how does the structure work, I can easily see how to get log n access through a tree structure  [14:33:23]
<pumpkin> roconnor: they can be amortized constant time, at least  [14:33:36]
<Cale> pumpkin: Immutable arrays in Haskell are primitive.  [14:33:40]
<pumpkin> oh  [14:33:44]
<edwardk> luqui: http://hpaste.org/12711  [14:34:05]
<luqui> http://hpaste.org/12710   m extensional equality on functions  [14:34:06]
<luqui> (certain functions)  this is common haskell lore by now  [14:34:18]
<luqui> edwardk, okay, simple enough.   sos to make it efficient...  [14:35:12]
<edwardk> the behavior can be extracted to yield its current value. it can have an instance of Comonadcontext added to allow it to be asked for the
          current time  [14:35:18]
<edwardk> well, you wanted safe, so i gave safe. efficient is tricky with the existential in there ;)  [14:35:43]
<luqui> efficient is tricky period  [14:35:52]
<edwardk> yeah  [14:35:57]
<edwardk> i do like the general direction though of this 'context comonad frp'  [14:36:44]
<luqui> yeah it's pretty cool.  a lot of avenues we haven't explored before  [14:37:06]
<edwardk> so one thought is the Clock b -> a part of the behavior can be replaced with something else, but i'd need to know where the inefficiencies come
          from  [14:38:15]
*** takinitez_ (n=jsch@111-194-103-86.dynamic.dsl.tng.de) is now known as takinitez  [14:39:12]
<jkff> Whoohoo, RWH has shipped to me in StaPetersburg!  [14:39:19]
<pumpkin> and to me in NH :)  [14:39:41]
<pumpkin> RWH all over the world!  [14:39:46]
<jkff> Tr00!  [14:39:53]
<luqui> edwardk, hmm.  the main thing is that we need to forget about the past.  [14:40:23]
<jkff> Or, to put it more functionally, \a b -> a  [14:40:42]
<edwardk> luqui: yeah, so far this only looks at the present for a behavior  [14:41:08]
<edwardk> you update it into the future by just bumping up the contents of the clock  [14:41:28]
<luqui> edwardk, oh, then the trick is locality.  usually it's easy to compute b (t+eps) using b t, for small eps  [14:41:36]
<edwardk> *nods* the other piece is that the equivalent formulation eneds to be done for Reactives  [14:42:11]
<luqui> well Reactives are simple if we have powerful behaviors  [14:42:41]
<edwardk> well, i have a memoizing context comonad, but it cheats  [14:42:49]
<edwardk> it internally unsafePerformIO's to memoize results  [14:43:10]
<luqui> pure memoization isn't really an option, because it's bad at forgetting  [14:44:01]
<edwardk> yeah  [14:44:05]
<edwardk> the idea there being that you bake in an LRU strategy or something, but since behaviors are modified incrementally you probably want to be able
          to update from a last position only.  [14:44:46]
<edwardk> if you really wanted to be fancy it'd be nice to have an accumulated error bound parameter, then this would be pretty simple  [14:45:36]
<luqui> edwardk, conal would be a fan of that  [14:45:54]
<edwardk> right now the 'naive' rep is (Time, Time -> a) right?  [14:45:56]
<luqui> yeah.  well, DTime -> as whatever that means.  I like (Time, Time -> a), because it allows me to stay in my safe, absolute time world  [14:46:23]
<vegai> ohh, my RWH is in the same country already  [14:49:13]
<vegai> giddyup, mail guys  [14:49:24]
<vegai> godspeed!  [14:49:30]
<edwardk> ok, well i'm sticking to Time, Time -> a, because i have a categorical justification for it, maybe something horrid like Behavior a = Behavior
          Time (Time -> a) (Time ->  a -> DeltaT -> Maybe a) which when you updated time by a DeltaT would check the update function and return the
          slightly modified value or soemthing  [14:49:43]
<edwardk> yay for too many parameters ;)  [14:50:01]
<christo_m> why cant i declare functions in GHC? like f x = x * x or something  [14:50:04]
<christo_m> its giving me some parse error about =  [14:50:09]
<vegai> would it be easy to make a simple game on Reactive?  [14:50:18]
<pumpkin> christo_m: let before that  [14:50:30]
<vegai> seems like a perfect fit, but is it in practice?  [14:50:31]
<pumpkin> christo_m: but it's less expressive than doing so in a file, as the pattern matching isn't as cool  [14:50:45]
<christo_m> pumpkin, but that reminds me of ocaml :(  [14:50:52]

[‘Îå 12‘ÔÂ  5 2008]
*** Topic for #haskell: ["Real World Haskell: it is alive!", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs:
    http://tunes.org/~nef/logs/haskell/"]  [21:40:46]
*** #haskell: topic set by dons, 10:49:38 2008/11/26
*** Users on #haskell: ManateeLazyCat vixey name ikkebr marko jberg- slash_ maltem tst__ mlesniak Eduard_Munteanu paolino vaskaren EmielRegis Dako-kun
    silentbob mc__ mikezackles Zero_In_Mood dmwit synthasee manicman njbartlett telexicon BONUS Deeem2031 darka yitz tomh Boney hrehf whoppix Neun
    papermachine Daniel_H SyntaxRebel skorpan oklopol dolio stevan funktio Lemmih dancor hs_noob nothingmuch _kayess InstantKofeGirl zax luite doublec
    Valodim hkBst bringert 
*** Users on #haskell: malcolmw jeremiah maattd jkff swiert ivanm smg Yoric[DT] yaxu amiddelk fasta lefant __me pcapriotti Schmallon AshyIsMe int-e
    al-maisan dibblego akafred niksnut aculich plikk aeolist QplQyer u_quark appletizer roderyk RayNbow adimit harinath Dessous shintah Axman6 pjdelport
    matthew-_ kynky wolverian xian iblechbot Itkovian_ jdrake sebbe1991 dreixel Shimei aik binrapt Taggnostr andyjgill naradapuri Aisling Philonous
    mmorrow mwhitney fortitude 
*** Users on #haskell: BeelsebobWork chylli Cale mml` Arnar_ Asztal jberg hydo scook0 ttmrichter_ Korollary gogonkt kpreid zeno Philippa_ geezusfreeek
    pumpkin george__ cnwdup dfeuer jekor Peaker pizza__ ksf CoryDambach jelmer kniu rdd blackh thingwath davidL kokekola elias` kfish Twey baaba MrDomino
    dje_ djinni araujo ulfdoz_ jan_ JuanDaugherty syscrash u51z3h4 easytiger rangaparma dejones JaffaCake ToRA|MSR wchogg atsampson OnionKnight
    cognominal pizza_ goober 
*** Users on #haskell: raxas mornfall mapreduce shrimpx gnufied tttm Eridius nasloc__ drbean nornagon mishok13 jajamana chipdude sbahra hackage purple__
    leimy xinming_ eno sjanssen maek te loop bohanlon lambdabot kar-1 puusorsa dino- linuxmain Cthulhon StoneToad proq strmnnrmn ajhager intrados
    DarthShrine Lor Lamperi gbacon saccade madnificent mm_freak arw andrewsw andun klugez arjanoosting opqdonut fnordus Zao Blub\0 Jaak matveev polux
    liesen jimki shepheb 
*** Users on #haskell: Botje czShadoW methos cjs fanf ned yango Debolaz Guest90792 GNU\caust1c noZone1 Igloo falseep kaol iggly_ clanehin Baughn saiam
    coldhak Bleadof QtPlatyp1s Liskni_si therp agentzh Beelsebob tarbo z|Andy MacTavish equanimi1y authentic Armored_Azrael Axioplase alexsuraci gwern
    SamB docmach roconnor borism tessier Jedai fredcy ArneB gpolo clad|sleep xcthulhu_ DuClare jaj PsiOmega welterde sereven kolmodin jeffersonheard
    nathanic dblazakis 
*** Users on #haskell: Riastradh Twigathy EvilTerran dmead score cpfr Plareplane dufflebu1k Mr_Awesome mlh SamB_XP lament bjorkLinux jfredett keseldude
    thetallgu1 mrd Deewiant snigel_ netcat r3m0t_ fophillips kpk leadnose djjack wolgo_ hukolele mightybyte yahooooo mopped_ thetallguy British0zzy
    shachaf mjrosenb cjb Khisanth Shurique m90 dvekravy randomit1 sbahra[] pauleeallen52 cinimod m4thrick birkenfeld tltstc lucca mux mercury^ pythonist
    kennyv lanaer tchakkazulu 
*** Users on #haskell: Megant pshc preflex SimonRC sutats Philippa shapr nnunley eyck Tigge Gabbie Soliah solrize_ lasts webframp pixel_ sclv olahol
    Raevel trez p_l wagle glguy mfp _MaK_ Ferdirand cjay bd_ stalker_ jonafan Elly aleator edwinb karld allbery_b pragma_ glith earthy PHO_ @ChanServ rog
    def__ im_maciek anders^^ slarba_ loupgaroublond liff Tomas taari frederik SubStack xHemi TML noj Badger lunabot nwf byorgey Poeir tromp liyang
    pengrate ibid c9s kosmikus 
*** Users on #haskell: DrSyzygy Skyp markovChain quicksilver viklund emma fadec maxote DarthMeh osfameron DustyDingo nemik juhp jml iratsu Nanar vegai
    Eelis fabjan boyscared levitation[A] mattam erg heavensrevenge m_stone daf dcoutts Wechner Japsu newt0n ksandstr kalven ahf mgregsond bmc_ mauke
    flori Apocalisp orbitz quuxman newsham felipe Nafai ziman agemo dionoea hesselink marmolak Giraffe wjt flux obraun wormcc stylus jmob cods Mitar
    sad0ur gdsx vincenz 
*** Users on #haskell: idnar MyCatVerbs tmoertel_away tote r0bby Laney Funjker_Boy22 ivan koninkje_away lilac regulate ski__ grul explicitjelly Vq^ jql
    And[y] Sartak DRMacIver mokus bockmabe Vulpyne Somni lispy inimino tmielika Draconx Choko dublpaws holzplatten suiside Caelum thedward Jiten tvaal
    chrisdone dons Pistahh C-Keen faXx sbok dcoutts_ Anthraxx miasma hellige joed chr1s shawn__ malouin Hunner thorkilnaur bran_ pcc1 tuukkah Spark laz0r
    clog twifkak 
*** Users on #haskell: desp znutar_ integral ertai xmux qebab rey_ nybyn rodge Ornedan IsoPallo_ MarcWeber Stephan202 gds ski_ decklin 
*** #haskell URL: http://www.haskell.org/  [21:40:47]
*** #haskell modes: +tncL  [21:41:08]
*** #haskell was created on ‘ÐÇ‘ÆÚ‘ÈÕ 2006/11/26 14‘Ê±42‘·Ö48‘Ãë
*** pizza__ (n=pizza@66.152.246.202) is now known as pizza_  [21:48:26]
<mlesniak> Currently I'm reading the tutorial on parallel and concurrent programming in haskell from SPJ but do not get any speedup in the example (even
           when using the f `par` (e `pseq` (e+f))). I remember to have read something about problems with ghc but can't remember where. Any hints?
                                                                                                                                                [21:50:08]
<mlesniak> (the fib + eulerSum example)  [21:50:20]
<blackh> I had a play myself for an evening.  [21:50:39]
<byorgey> mlesniak: what version of GHC are you using?  [21:50:46]
<blackh> I found it was rather tricky to get the granularity right with `par`  [21:50:58]
<mlesniak> byorgey: 6.10.1  [21:51:06]
<byorgey> mlesniak: IIRC there's a bug in GHC 6.10.1 where if you only have one spark it won't fire up another thread, or something like that.  I don't
          know if that's the problem you're experiencing.  [21:51:44]
<mlesniak> blackh: Probably. But this is were the tutorial starts and I think it's a good starting point (in theory)  [21:51:46]
<mlesniak> byorgey: at least this would explain the behaviour I'm observing  [21:52:04]
<byorgey> ok, that's probably it then  [21:52:29]
<blackh> I tried to do it with an anagram generator, but it spent almost all of its time allocating memory. :)  [21:52:30]
<byorgey> apparently this will be fixed in 6.10.2  [21:52:45]
<mlesniak> byorgey: any idea when it will be released? i.e. any time soon or in a few months ?  [21:53:03]
<byorgey> mlesniak: no idea.  [21:53:11]
<maltem> didn't they plan periodic releases for ghc now?  [21:56:45]
<maltem> I think there was some rumour of that sort  [21:57:05]
<maltem> or maybe I'm confusing with darcs  [21:57:41]
<Eduard_Munteanu> Hooray, just wrote an integration function in Haskell. Quite elegant.  [21:57:46]
<vixey> numerical integration?  [21:58:03]
<Eduard_Munteanu> vixey, yes, it takes a function, the limits of integration and step size  [21:58:23]
<vixey> cool  [21:58:27]
<tomh> hey how do you escape chars in strings for haskell?  [21:58:44]
*** ikkebr (n=ikkibr@189-72-1-168.smace700.dsl.brasiltelecom.net.br) is now known as ikkebr_gone_comp  [21:58:50]
<blackh> \  [21:58:51]
<byorgey> maltem: you may also be confusing it with the Haskell language standard  [21:58:52]
<tomh> somehow it still displays \ everywhere  [21:58:57]
<byorgey> for which there will now be regular periodic updates.  [21:59:04]
<ogex> Eduard_Munteanu, what kind of functions does it get?  [21:59:06]
<blackh> tomh: paste what you've done  [21:59:14]
<vixey> tomh: hhat's because haskell escapes too  [21:59:16]
<byorgey> Eduard_Munteanu: congrats!  [21:59:24]
<Eduard_Munteanu> ogex, Double -> Double  [21:59:28]
<Eduard_Munteanu> Thanks  [21:59:35]
<tomh> let me make a small testcase  [21:59:58]
<byorgey> tomh: you mean you want to print out a string without it displaying escape \ chars ?  [22:00:01]
<tomh> yes  [22:00:07]
<byorgey> ok, then you should use 'putStr'  [22:00:13]
<byorgey> or putStrLn  [22:00:16]
<tomh> ok thanks  [22:00:42]
<byorgey> if you 'show' a string (or just enter an expression at the ghci prompt that evaluates to a String) it will show it with escapes  [22:00:44]
<blackh> Also 'show' puts quotes around it.  [22:01:10]
<byorgey> the point is to print a representation which is valid Haskell syntax for itself  [22:01:14]
<byorgey> right.  [22:01:16]
<byorgey> whereas  putStr(Ln) are for doing actual output, rather than just displaying the value of a String.  [22:01:55]
<tomh> i see ok  [22:02:19]
<Eduard_Munteanu> Here it is, http://pastebin.com/d5086be1c  [22:02:44]
<alar> can anybody help me with MPTC?  [22:03:01]
<alar> I want to define class "collection that collects keys 'k' with values 'v'" and state that "Data.Map.Map k [v] is an instance of it"  [22:03:02]
<Eduard_Munteanu> well, I wrote it how I knew best, it doesn't mean it's really the best way.  [22:03:11]
<alar> can't figure what lines with "class MyColl" and "instance MyColl" should look like  [22:03:32]
<byorgey> Eduard_Munteanu: nice.  [22:03:44]
<quicksilver> alar: class MyColl c k v where h  [22:03:47]
<vixey> @src sum  [22:03:53]
<lambdabot> sum = foldl (+) 0  [22:03:54]
<orbitz> alar: liek the syntax?  [22:03:56]
<quicksilver> alar: instance MyColl (Map k [v]) k v  [22:03:59]
<orbitz> alar: any haskell book/tutorial will cover it  [22:04:03]
<quicksilver> I doubt that.  [22:04:14]
<quicksilver> Very few haskell tutorials mention MPTCs.  [22:04:23]
<quicksilver> alar: you may also want c -> k, c -> v in the class definition.  [22:04:37]
<alar> quicksilver: and MPTC and "flexible instances" extensions enabled?  [22:04:42]
<quicksilver> depending what your intentions are.  [22:04:44]
<orbitz> ohh ok, specific to MPTCs, sorry  [22:04:49]
<byorgey> Eduard_Munteanu: I would probably pass the number of steps as a parameter rather than the step size  [22:04:53]
<quicksilver> alar: yes, at least those.
<quicksilver> alar: probably FunctionalDependencies too, for the last part.  [22:05:03]
<Eduard_Munteanu> byorgey, oh, I see. I thought the step size could provide some (rather bad) indication of precision, i.e. error.  [22:05:49]
<alar> quicksilver: I'm not quite sure about fundeps, but it is not hard to figure whether I need them  [22:05:57]
<EvilTerran> with fundeps, it'd be "class MyColl c k v | c -> k v where s"  [22:06:13]
<byorgey> Eduard_Munteanu: well, you can do it either way, it's not really that important  [22:06:17]
<EvilTerran> and the instance would look the same  [22:06:25]
<byorgey> Eduard_Munteanu: I guess it depends how you want to think about the precision m in absolute or relative terms  [22:06:49]
<Eduard_Munteanu> Yeah.  [22:07:02]
<quicksilver> alar: FWIW, this all looks a bit nicer with associated types.  [22:07:05]
<quicksilver> Mind you I don't know how to use them, so I couldn't help you there :)  [22:07:12]
<SamB_XP> quicksilver: how do you know it looks nicer, then ?  [22:08:02]
<EvilTerran> "class MyColl t where type Key t; type Val t; s; get :: t -> Key t -> Val t; ..." or whatever  [22:08:03]
<byorgey> Eduard_Munteanu: you could also specify 'pairs' like this:  [22:08:04]
<ziman> @index CReal  [22:08:13]
<lambdabot> bzzt
<byorgey> steps = [a, a+stepsize i b]  [22:08:25]
<vixey> You can get lower and upper bounds by summing the rectangles below vs above  [22:08:29]
<EvilTerran> "instance MyColl (Map k [v]) where type Key (Map k [v]) = k; type Val (Map k [v]) = v; s"  [22:08:34]
<byorgey> pairs = zip steps (tail steps)  [22:08:35]
<alar> quiksilver: I'm not sure how  [22:08:43]
<Eduard_Munteanu> byorgey, uh, that's the first thing I tried, but it erred out. It says something about [Enum (Double, Double)]  [22:08:54]
<vixey> @let pairs = zip steps (tail steps)  [22:09:04]
<alar> should I create type family "collection" associated with class MyColl?
<lambdabot>  <local>:1:12: Not in scope: `steps'  [22:09:05]
<lambdabot>  
<lambdabot>  <local>:1:24: Not in scope: `steps'
<EvilTerran> alar, i just gave an example of associated types  [22:09:11]
<vixey> @let pairs steps = zip steps (tail steps)
<lambdabot>  Defined.  [22:09:13]
<vixey> > (pairs . pairs . pairs) "xyz"  [22:09:21]
<lambdabot>   []  [22:09:22]
<vixey> > (pairs . pairs . pairs) "xyzw"  [22:09:28]
<lambdabot>   [((('x','y'),('y','z')),(('y','z'),('z','w')))]  [22:09:29]
<alar> oh, thanks  [22:09:30]
<byorgey> Eduard_Munteanu: if it said something about Enum (Double, Double) then you didn't do exactly what I typed above =)  [22:09:32]
<alar> EvilTerran: the syntax looks a bit nicer  [22:09:52]
* alar goes to check if it will work  [22:10:05]
<byorgey> Eduard_Munteanu: you first compute the list of Doubles which are the division points: [a, a+stepsize i b]  [22:10:13]
<byorgey> Eduard_Munteanu: then you zip those up offset by one to get a list of pairs  [22:10:29]
<Eduard_Munteanu> byorgey, oh, I see. What I had tried was different.  [22:11:14]
<EvilTerran> alar, to be honest, i find the associated type syntax to be a bit clunky  [22:11:19]
<SamB_XP> EvilTerran: yeah ?  [22:12:05]
<EvilTerran> especially when you're being olegian and your types get really long  [22:12:09]
<byorgey> Eduard_Munteanu: also, foldr (+) 0 === sum  [22:12:11]
<EvilTerran> it's annoying to have to give them repeatedly  [22:12:15]
<Axman6> @pl \xs -> zip xs (tails xs)  [22:12:20]
<lambdabot> ap zip tails
<alar> EvilTerran: in GHC docs it looks sstrange, but in your example, it's rather nice  [22:12:29]
<Axman6> @quote zip`ap`tails  [22:12:39]
<lambdabot> No quotes match. Wrong!  You cheating scum!  [22:12:40]
<orbitz> :t ap  [22:12:41]
<lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b  [22:12:42]
<quicksilver> @quote aztec  [22:12:44]
<lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers  [22:12:45]
<Axman6> that's the one i was after :)  [22:12:53]
<Eduard_Munteanu> byorgey, oh, I'll fix that. foldr (+) 0 is a common example in tutorials so I got stuck with it.  [22:13:02]
<orbitz> > zip`ap`tail  [22:13:12]
<byorgey> Eduard_Munteanu: heh, right  [22:13:13]
<lambdabot>       Overlapping instances for Show ([b] -> [(b, b)])
<lambdabot>        arising from a s
<byorgey> Eduard_Munteanu: but anyway, this is a great start!  [22:13:21]
<Eduard_Munteanu> Thanks.  [22:13:34]
<Axman6> > zip `ap` tail [1i10]  [22:13:52]
<lambdabot>   Couldn't match expected type `[a] -> [b]'  [22:13:53]
<orbitz> > ap zip tails [1, 2, 3]  [22:13:58]
<Axman6> > (zip `ap` tail) [1i10]
<lambdabot>   [(1,[1,2,3]),(2,[2,3]),(3,[3])]  [22:14:00]
<lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
<vixey> > pairs [1i10]  [22:14:27]
<lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]  [22:14:29]
<byorgey> now look what I've started!  [22:14:56]
<alar> it compiles!!!  [22:15:39]
<alar> @karma+ quicksilver  [22:15:46]
<lambdabot> quicksilver's karma raised to 5.  [22:15:47]
* quicksilver blinks  [22:16:36]
<quicksilver> 5?  [22:16:37]
<quicksilver> OK, I'm not exactly a karma whore  [22:16:44]
<quicksilver> but surely in 3 years on the channel I've earnt more than 5?  [22:16:53]
<SamB_XP> quicksilver: probably  [22:17:13]
<vixey> @karma quicksliver  [22:17:19]
<lambdabot> quicksliver has a karma of 0
<SamB_XP> lambdabot is always losing it  [22:17:21]
<int-e> @karma  [22:17:32]
<lambdabot> You have a karma of 1  [22:17:33]
<SamB_XP> @karma  [22:17:36]
<lambdabot> You have a karma of 0  [22:17:37]
<quicksilver> lambdabotm # losing it  [22:17:42]
<SamB_XP> I used to have some karma, too ;-P  [22:17:44]
<vixey> @camelion
<int-e> state resets :/  [22:17:45]
<lambdabot> Unknown command, try @list
<byorgey> preflex: karma quicksilver  [22:17:47]
<preflex>  karma for quicksilver: 15
<quicksilver> preflex: karma lambdabot  [22:17:56]
<preflex>  karma for lambdabot: 2  [22:17:57]
<SamB_XP> preflex: karma  [22:18:00]
<preflex>  SamB_XP has no karma
<SamB_XP> preflex: karma SamB  [22:18:04]
<preflex>  karma for SamB: 3  [22:18:05]
<Eduard_Munteanu> > show [1i]  [22:18:18]
<lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2s  [22:18:19]
<int-e> @karma moritz
<lambdabot> moritz has a karma of 248  [22:18:20]
<alar> @where SPOJ
<lambdabot> http://www.spoj.pl/  [22:18:21]
<Eduard_Munteanu> Uh, had to try it.  [22:18:29]
<Eduard_Munteanu> :P  [22:18:33]
<byorgey> Eduard_Munteanu: hehe =)  [22:18:35]
<jkff> @karma  [22:19:34]
<lambdabot> You have a karma of 0  [22:19:35]
<jkff> Wow, not much  [22:19:37]
<int-e> jkffm m could be worse ;)  [22:19:50]
<Eduard_Munteanu> @karma  [22:19:52]
<lambdabot> You have a karma of 0  [22:19:53]
<int-e> @karma jkff  [22:19:56]
<lambdabot> jkff has a karma of -1
<int-e> jkff++  [22:19:59]
<jkff> Oh, that's how it's done  [22:20:11]
<jkff> int-e++  [22:20:22]
<jkff> for pointing out :)  [22:20:24]
<Eduard_Munteanu> Uh, that's not pure.  [22:20:28]
<alar> @karma jkff  [22:20:39]
<ksf> preflex, nickometer
<lambdabot> jkff has a karma of 0  [22:20:40]
<byorgey> someone should really write a little program to parse all the #haskell logs and construct a 'canonical' \bot state
<preflex>  ksf is 0% lame
<lilac> @karma lunabot  [22:20:44]
<lambdabot> lunabot has a karma of 0  [22:20:45]
<Eduard_Munteanu> That's imperative.  [22:20:48]
<opqdonut> preflex: nickometer  [22:21:07]
<preflex>  opqdonut is 0% lame
<opqdonut> @karma  [22:21:09]
<lambdabot> You have a karma of 0  [22:21:10]
<opqdonut> hmm  [22:21:13]
<opqdonut> preflex used to give me 70% or something  [22:21:19]
<SamB_XP> byorgey: what about -blah ?  [22:21:24]
<opqdonut> preflex: nickometer ^hello73Tharr_  [22:21:31]
<byorgey> SamB_XP: that too.
<preflex>  ^hello73Tharr_ is 73% lame
<opqdonut> *shrug*  [22:21:37]
<SamB_XP> -blah is logged ???  [22:21:40]
<byorgey> SamB_XP: oh, no, of course not.  [22:21:56]
<SamB_XP> well, what I really mean is publicly logged  [22:22:18]
<SamB_XP> I expect the logs exist s  [22:22:24]
<byorgey> I guess if anyone gave anyone else karma in -blah it is lost forever.  [22:22:29]
<byorgey> it's definitely not publicly logged  [22:22:42]
<SamB_XP> yes, far too much sex in it for that  [22:23:00]
<opqdonut> or then there should be a channel #lambdabot where the different lambdabots could dump their states  [22:23:13]
<opqdonut> and somebody would offer public logs  [22:23:18]
<byorgey> Eduard_Munteanu: yes, Haskell is the best imperative language in the world =)  [22:23:20]
<alar> lambdabot is just multiplayer GHCi  [22:23:28]
<alar> what's preflex?  [22:23:33]
<EvilTerran> preflex: version  [22:23:43]
<preflex>  4.166  [22:23:44]
<Saizan> what about fixing the state serialization?
<EvilTerran> hm  [22:23:46]
<int-e> karma is overrated :)  [22:23:47]
<byorgey> alar: a bot mauke wrote, I think  [22:23:48]
<Eduard_Munteanu> byorgey, yeah, monads rock  [22:23:55]
<SamB_XP> preflex: about  [22:24:40]
<lilac> preflex: nickometer  [22:24:47]
<preflex>  lilac is 0% lame
<lilac> yay  [22:24:51]
<SamB_XP> preflex: who are you ?  [22:24:52]
<lilac> preflex++  [22:24:56]
<SamB_XP> preflex: help  [22:25:02]
<preflex>  try 'help help' or see 'list' for available commands
<Baughn> preflex: nickometer  [22:25:03]
<preflex>  Baughn is 0% lame  [22:25:04]
<SamB_XP> preflex: list  [22:25:07]
<preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, m, karma, karmabot, karmatop];
          Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote,
          remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
<Axman6> preflex: Factoid: ?  [22:25:28]
<opqdonut> preflex: quote  [22:25:35]
<preflex>  <procyon> optimizing bubblesort is like masturbating.  Sure, it's not going to do you much good in the long run, and it's probably a waste of
          time, but it still feels good.  [22:25:36]
<SamB_XP> mmmkay s  [22:25:58]
<jkff> preflex: help cdecl  [22:26:00]
<preflex>  cdecl DECLARATION - explain a C declaration
<int-e> preflex: zenc @#$%^&*()_+  [22:26:14]
<jkff> preflex: cdecl int f(char *s)
<preflex>  z40UzhzdzvzczaztZLZRzuzp
<preflex>  f: function(s: pointer to char) returning int  [22:26:16]
<jkff> Very nice  [22:26:21]
<jkff> As if I didn't knew myself  [22:26:27]
<EvilTerran> preflex: cdecl int (*foo) (int (*) bar)  [22:26:40]
<preflex>  missing ')'
<jkff> preflex: cdecl int (*)(*)  [22:26:51]
<preflex>  missing type
<EvilTerran> preflex: cdecl int (*foo) (int (*) (int))  [22:26:53]
<preflex>  foo: pointer to function(pointer to function(int) returning int) returning int  [22:26:54]
<jkff> preflex: cdecl int (*)(int (*)(int))  [22:26:58]
<preflex>  pointer to function(pointer to function(int) returning int) returning int
<opqdonut> :)  [22:27:00]
<jkff> Now try some boob combinator  [22:27:11]
<jkff> preflex: cdecl (.) . (.)  [22:27:15]
<preflex>  missing type  [22:27:16]
<SamB_XP> jkff: you silly  [22:27:23]
<SamB_XP> you know that isn't valid C  [22:27:27]
<Axman6> :t (.).(.)  [22:27:37]
<int-e> SamB_XP: oh?  [22:27:38]
<lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
<jkff> preflex does, too  [22:27:39]
<Saizan> no boobs for C!  [22:27:40]
<lilac> preflex: cdecl void*(*f((*)()))()[10]  [22:27:45]
<preflex>  missing type  [22:27:46]
<jkff> That's the point
<BeelsebobWork> Axman6: fmap . fmap is rather more useful than boobs unfortunately  [22:27:53]
<opqdonut> BeelsebobWork: not if (.)=fmap  [22:28:05]
<lilac> preflex: cdecl void*(*f(int(*)()))()[10]  [22:28:06]
<preflex>  trailing garbage  [22:28:07]
<lilac> :(  [22:28:13]
<SamB_XP> :t fmap . fmap  [22:28:19]
<lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)  [22:28:20]
<vixey> preflex: cdecl printf("hello");  [22:28:21]
<preflex>  missing type  [22:28:22]
<BeelsebobWork> opqdonut: yes m but (.) *shouldn't* equal fmap -- (.) is function composition  [22:28:24]
<SamB_XP> :t fmap fmap fmap  [22:28:27]
<lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)  [22:28:28]
<jkff> preflex: rot13 (.) . (.)  [22:28:29]
<preflex>  (.) . (.)
<Axman6> BeelsebobWork: when boobs fail, time to fap.fap?  [22:28:34]
<BeelsebobWork> the two just happen to be the same in the function case
<jkff> Hm. Rotated boobs are boobs still?  [22:28:40]
<Axman6> uh, fmap.fmap >_>  [22:28:41]
<BeelsebobWork> Axman6: when boobs fail time to fmap fmap fmap  [22:28:48]
<jkff> preflex: rot13 fmap.fmap  [22:28:50]
<preflex>  sznc.sznc  [22:28:51]
<lilac> Peaker: you about?  [22:28:54]
<lilac> preflex: rot13 boobs  [22:29:07]
<preflex>  obbof
<Axman6> @unpl (.).(.)  [22:29:14]
<lambdabot> (\ i b c f -> i (b c f))
<SamB_XP> why i b c f?  [22:29:33]
<jkff> preflex: help wcalc  [22:29:35]
<preflex>  wcalc: alias of calc  [22:29:36]
<jkff> preflex: help calc  [22:29:41]
<preflex>  calc EXPR - evaluate an arithmetic expression  [22:29:42]
<BeelsebobWork> @check let fap = fmap in \f x -> ((.) . (.)) f x == (fap fap fap) f x  [22:29:43]
<quicksilver> :t (.)  [22:29:45]
<lambdabot>       Overlapping instances for Show ((b -> b1) -> (b -> b1) -> b)  [22:29:46]
<lambdabot>        aris
<lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
<BeelsebobWork> bah  [22:29:47]
<BeelsebobWork> :(  [22:29:50]
<quicksilver> SamB_XP: no idea.  [22:29:51]
<jkff> preflex: calc (+) 1 2  [22:29:53]
<preflex>  3  [22:29:54]
<jkff> preflex: calc (.) . (.)  [22:29:58]
<preflex>  Lexical error
<BeelsebobWork> I wanted lambdabot to proved boobs equaled fap fap fap  [22:29:59]
<jkff> preflex: calc (+1) 2  [22:30:06]
<preflex>  3  [22:30:07]
<ksf> rotating boobs is both value- and  structure-preserving
<lilac> SamB_XP: i'd guess that the other letters appeared and disappeared during expansion of the type  [22:30:08]
<vixey> preflex: calc (((((((((((4(((()))))))))))()(+)(((((((((((8)))))))))))))))()  [22:30:15]
<preflex>  12  [22:30:16]
<jkff> Rotation is a boobomorphism  [22:30:19]
<SamB_XP> @unpl (.).(.).(.)  [22:30:29]
<lambdabot> (\ l b c f i -> l (b c f i))
<int-e> vixey: ouch!  [22:30:32]
<jkff> preflex: calc ()  [22:30:52]
<preflex>  Not enough mana  [22:30:53]
<EvilTerran> !  [22:30:57]
<jkff> preflex: calc ()()  [22:30:59]
<preflex>  Not enough mana  [22:31:00]
<jkff> preflex: calc )1(  [22:31:06]
<preflex>  1  [22:31:07]
<SamB_XP> preflex: help calc  [22:31:09]
<preflex>  calc EXPR - evaluate an arithmetic expression  [22:31:10]
<SamB_XP> preflex: help Calc  [22:31:14]
<preflex>  unknown command: Calc
<int-e> preflex: calc )  [22:31:18]
<preflex>  Not enough mana
<int-e> preflex: calc )1  [22:31:20]
<preflex>  1
<lilac> preflex: calc )))1+2)))  [22:31:22]
<preflex>  3  [22:31:23]
<jkff> preflex: calc +  [22:31:29]
<preflex>  Not enough mana
<lilac> preflex: calc (2*2)+3  [22:31:34]
<preflex>  7
<lilac> preflex: calc 2*(2+3)  [22:31:42]
<preflex>  10
<vixey> preflex calc: 1!2@3#4$5%6^7&8*9(0)  [22:31:43]
<lilac> preflex: calc 2*)2+3(  [22:31:48]
<preflex>  7  [22:31:49]
<int-e> preflex: calc ><(((1)>  [22:31:51]
<preflex>  Lexical error
<jkff> preflex: calc 5!  [22:31:54]
<preflex>  Lexical error
<vixey> preflex: calc 1!2@3#4$5%6^7&8*9(0)  [22:31:58]
<preflex>  Lexical error  [22:31:59]
<int-e> weird  [22:32:06]
<jkff> preflex: calc 2*(3+4)
<preflex>  14  [22:32:07]
<vixey> preflex: calc 9(0)  [22:32:11]
<preflex>  Too many operands  [22:32:12]
<vixey> preflex: calc (0)  [22:32:16]
<jkff> preflex: calc 2*)3+4(
<preflex>  10
<preflex>  0  [22:32:18]
<vixey> preflex: calc pi  [22:32:19]
<preflex>  3.141592653589793  [22:32:20]
<Axman6> heh, that reminds me of something i saw on out uni forums. turns out that ()())()()()()()()()()()()()()()()()()()()()()()()( really large and in
         <marquee> tags looks a lot like dancing legs  [22:32:21]
<SamB_XP> preflex: calc 1)  [22:32:22]
<int-e> preflex: calc 2*(2+3)
<preflex>  1
<vixey> preflex: calc e  [22:32:23]
<preflex>  10  [22:32:24]
<lilac> preflex: calc (2*)2+3(  [22:32:25]
<preflex>  2.718281828459045  [22:32:26]
<preflex>  7  [22:32:28]
<int-e> preflex: calc )2*(2+3)  [22:32:29]
<preflex>  10  [22:32:30]
<lilac> preflex: calc (2*)(2+3(  [22:32:43]
<preflex>  7  [22:32:44]
<Axman6> preflex: cals e ^ (i*pi) + 1  [22:32:53]
<lilac> preflex: calc (2*(2+3)
<preflex>  10  [22:32:54]
<Axman6> preflex: calc e ^ (i*pi) + 1  [22:32:57]
<preflex>  Lexical error
<jkff> preflex: calc i  [22:33:05]
<preflex>  Lexical error
<Axman6> preflex: calc 2 ^ 4  [22:33:07]
<preflex>  16  [22:33:08]
<Axman6> preflex: calc e ^ (‘¡Ì(-1)*pi) + 1  [22:33:23]
<preflex>  Lexical error
<Axman6> >_>  [22:33:26]
<jkff> preflex: help nickr  [22:33:33]
<preflex>  nickr NICK - increment NICK
<jkff> preflex: nickr jkff  [22:33:39]
<preflex>  jkff_
<jkff> preflex: nickr jkff_  [22:33:44]
<preflex>  jkf_f  [22:33:45]
<vixey> preflex: nickr vixey  [22:33:50]
<preflex>  vixey_  [22:33:51]
<jkff> preflex: iterate nickr jkff  [22:33:54]
<opqdonut> stop the floor already  [22:34:08]
<jkff> preflex: nickr 0  [22:34:15]
<preflex>  0_
<jkff> preflex: nickr _  [22:34:17]
<preflex>  a  [22:34:18]
<jkff> preflex: nickr a  [22:34:20]
<preflex>  a_
<jkff> preflex: nickr a_  [22:34:22]
<preflex>  b  [22:34:23]
<jkff> preflex: nickr z_  [22:34:26]
<preflex>  a[  [22:34:27]
<opqdonut> *flood  [22:34:36]
<Axman6> preflex: help nickr  [22:34:44]
<preflex>  nickr NICK - increment NICK  [22:34:45]
<Axman6> eh?  [22:34:59]
<jkff> Just in case your nick isn't big enough  [22:35:19]
<quicksilver> I call "enough bot games", I think.  [22:35:25]
<quicksilver> Feel free to continue in -blah or privmsg :)  [22:35:33]
<BeelsebobWork> @vixen have we played with the bot enough? >.>  [22:35:50]
<quicksilver> and summarise the funniest discoveries here, of course.
<lambdabot> bots should be destroyed. they are so annoying  [22:35:51]
<BeelsebobWork> I think that settles it :)  [22:36:00]
<ksf> preflex, 8ball will #haskell stop playing with bots?  [22:36:32]
<preflex>  cannot predict now  [22:36:33]
<vixey> jkff, I printed and reread the Theroems for Free paperi still lost :/  [22:40:14]
<vixey> also I had a look at the haskell implementation but it didn't really help  [22:40:33]
<vixey> (still wondering how to define the relation)  [22:40:45]
<byorgey> yeah, that Theorems for Free paper is not easy to follow  [22:41:44]
<byorgey> I think I've read it thrice now  [22:42:02]
<wchogg> Well, I think it helps to keep in mind the whole natural transformations picture the whole time.  [22:42:05]
<wchogg> I said 'whole' twice in that sentence.  I should be slapped.  [22:42:39]
<vixey> I don't really know the natural transformsi  [22:43:20]
<byorgey> @slap wchogg  [22:43:27]
* lambdabot submits wchogg's email address to a dozen spam lists  [22:43:28]
<wchogg> oh noes!  [22:43:35]
<goober> soh  [22:49:37]
*** goober (n=Goobre@cpe-76-172-169-17.socal.res.rr.com) is now known as Goober  [22:49:42]
<Goober> why can't there be a "low level Haskell" ?  [22:50:02]
<Goober> which directly translates into opcodes the same way as C does  [22:50:17]
<Goober> why does Haskell ihave to be high level  [22:50:47]
<vixey> Goober, 1) C doesn't do that 2) There already is  [22:50:57]
<Philippa> because it wouldn't be Haskell otherwise  [22:51:03]
<Goober> vixey: 1) Yes it does  [22:51:05]
<Philippa> Goober: ever used a C compiler on a system with no hardware stack?  [22:51:22]
<Philippa> and that's before you run stuff through an optimiser  [22:51:39]
<Philippa> C is /not/ a portable assembler  [22:51:45]
<Goober> irrelevant, I'm talking about 99% of C implementations  [22:51:47]
<vixey> Goober, (not sure why you'd ask a question then just argue with the answers, but whatever)  [22:51:50]
<Philippa> you mean the 99% that you pulled out of your arse that nobody uses?  [22:52:05]
<vixey> hehe  [22:52:49]
<Goober> vixey: because you're being flippant  [22:52:51]
* sw17ch is very bad at writing portable C codes  [22:53:08]
<Goober> C has a high level of correlation to direct ASM code  [22:53:23]
<sw17ch> either that, or theres some mysterious reason that my 16bit C code doesn't work on my 8bit systems :)  [22:53:31]
<Goober> on 99.9% of compilers  [22:53:32]
<lilac> Goober: that seems to be the answer to your question  [22:53:35]
<Philippa> ooh, you found another 900 compilers?  [22:53:49]
<lilac> C corresponds better to Von Neumann architectures than Haskell does
* sw17ch realizes he walked into a holy war and backs away  [22:54:08]
<Goober> I don't think the conversation benefits from hair-splitting that vixey attempts  [22:54:35]
<lilac> Goober: there's a tendency for people here to dislike made-up facts  [22:54:43]
<Philippa> that's okay: we don't think it benefits from you  [22:54:46]
<Philippa> lilac: ITYM "facts" :-)  [22:55:05]
<Goober> It's not "made up", but you guys have some strong desire towards retardation and focusing on obscure compilers  [22:55:27]
<Goober> you obviously know what I'm saying  [22:55:33]
<lilac> Goober: we like people to state sources for facts, or state opinions as opinion rather than fact  [22:55:34]
<Axman6> Goober: look in GHC.Prim  [22:55:35]
<Philippa> GCC is obscure?  [22:55:37]
* vixey goes to get more sunflower seeds  [22:55:38]
<Goober> abouot C to asm
<Eduard_Munteanu> Can Haskell compilers output non-interpreted code? I mean something like C-like executable code, my simple program is a huge 864KiB
                 when compiled.  [22:55:42]
<Philippa> optimising compilers are obscure?  [22:55:49]
<Philippa> wow, what world do you live in?  [22:55:54]
<Goober> Philippa: obscure targets
<Axman6> Philippa: of course!  [22:55:55]
<lilac> Goober: have you seen anything about the Reduceron?  [22:56:13]
<Philippa> Goober: the one I had in mind was a games console sitting about 2m away from me
<Eduard_Munteanu> I mean, can it drop lazy evaluation and such things in compiled code?  [22:56:16]
<fasta> Is there a way to download all the packages on hackage, unpack them, so I can grep over them? (other than just writing the script myself to do
        so)  [22:56:19]
<sw17ch> Eduard_Munteanu: Haskell is statically linked. GHC will happily interpret code, or compile it for you.  [22:56:21]
<Goober> Philippa: gcc at -O3 does not make the asm correspond to the code any less than no -O3  [22:56:24]
<Philippa> the bestseller in its generation  [22:56:30]
<sw17ch> Eduard_Munteanu: the reason it's big is probably b/c of the static linkage  [22:56:31]
<Goober> They have the same level of correspondence  [22:56:35]
<sw17ch> Eduard_Munteanu: make a C program, and compile it with -static  [22:56:37]
<sw17ch> and then compare the sizes  [22:56:43]
<scook0> "dropping lazy evaluation" is called strictness analysis, and much work has been done on it  [22:57:05]
<Goober> the No -O3 has slightly better locality  [22:57:11]
<Eduard_Munteanu> sw17ch, oh, my understanding was that Haskell includes some interpreter in executables. Thanks, it sounds okay now.  [22:57:13]
<fasta> Eduard_Munteanu: there are compilers that create smaller binaries. IIRC nhc98 does that.  [22:57:25]
<sw17ch> Eduard_Munteanu: no, it's actually very good ASM code for the most part  [22:57:31]
<Goober> In the case of inlining  [22:57:44]
<fasta> Eduard_Munteanu: but nhc98 is fairly unsupported now.
<Philippa> Eduard_Munteanu: there's a runtime system, but that's not the same as a virtual machine - C implementations have RTSes too  [22:57:46]
<fasta> Eduard_Munteanu: and see Philippa for why GHC's is that big.  [22:58:02]
<paolino> fasta :http://hackage.haskell.org/cgi-bin/hackage-scripts/archive.tar maybe  [22:58:13]
<Philippa> of course, the other reason C makes a crap portable assembler is that it's not low level enough  [22:58:19]
* sw17ch notes that he can follow the output from gcc -S -O, but cannot follow (without some serious work) the output from gcc -S -O3  [22:58:20]
<vixey> mm  [22:58:31]
<sw17ch> even on happy architectures like PPC
<vixey> 'kind' and 'type' are bad choices of names  [22:58:33]
<Goober> sw17ch: You get used to it  [22:58:40]
<Eduard_Munteanu> So careful coding (where possible) in Haskell should yield machine code just as performant as C counterparts?
<wchogg> vixey:  why?  [22:58:42]
<Philippa> vixey: 'sort' is better?  [22:58:44]
<vixey> sort is better  [22:58:49]
<malcolmw> Eduard_Munteanu: fasta: even though nhc98 is not actively developed, it is certainly maintained.  [22:58:53]
<sw17ch> Goober: i should hope i get betters since it's kinda waht i do for a living :\  [22:58:58]
<lilac> vixey: and class?  [22:59:00]
<vixey> wchogg, in this source code:  match kind_of_term t1, kind_of_term t2 with  [22:59:09]
<vixey> it's not immediately clear what "kind" means here  [22:59:22]
<fasta> malcolmw: ok, sorry about that.  [22:59:23]
<Philippa> Eduard_Munteanu: within the same ballpark generally, yeah  [22:59:25]
<sw17ch> Goober: but some of the more advanced flow analysis conditions and crazy inlining in various places gets thick in a hurry  [22:59:26]
<Goober> anyways, my point comes from reading my asm regularly m whereas vixey's "it doesn't correspond to asm" is theoretical about "implementations"
                                                                                                                                                [22:59:30]
<Eduard_Munteanu> Philippa, thanks.  [22:59:37]
<vixey> Goober, going to /ignore you if you keep hilighting me  [22:59:44]
<Philippa> Goober: seeing as you pulled 99.9% out of your arse I don't think you've much room to talk there  [22:59:54]
<Goober> fuck you?  [22:59:55]
<Goober> what is your problem, vixey  [23:00:01]
<Philippa> I highly doubt you've used 1000 different implementations and examined their asm  [23:00:05]
<Axman6> Goober: what's your problem? you've been rude and aggressive in an otherwise friendly and helpful channel. vixey isn't the one in the wrong
                                                                                                                                                [23:00:27]
<Goober> Philippa: why focus on such trivialties?  [23:00:30]
<fasta> paolino: where did you get that link?  [23:00:32]
<sw17ch> I've used two compilers where i inspected the resultant machien codes the Obfuscated C Code compiler entry and GCC  [23:00:38]
<Goober> Axman6: Fuck you as well.  [23:00:39]
<Philippa> Goober: why not? You're fond of it
<paolino> fasta : main page  [23:00:53]
*** ChanServ (ChanServ@services.) has changed mode for #haskell to +o Philippa  [23:00:55]
<Eduard_Munteanu> And here's another question that bugs me. Can, by its functional form, Haskell code be compiled into in-place code where possible?
                 Somebody said finding a general algo for this is NP-hard, is this correct?  [23:01:03]
<Philippa> Goober: say "fuck you" one more time?  [23:01:04]
<Goober> Scroll back to the start of the convo  [23:01:15]
<Axman6> Goober: you're talking to a lot of people who know what they're on about. stop fighting and start learning or leave  [23:01:37]
<lilac> Goober: we all know what's been said. you've made assertions, you've not backed them up.  [23:01:38]
<vixey> Eduard_Munteanu: what exactly is in-place ?  [23:01:39]
<fasta> paolino: ah, nice that they thought of this.  [23:01:40]
<sw17ch> Eduard_Munteanu: by in place, do you mean tail recursive
<Philippa> you mean the start where you got answers you didn't like?  [23:01:47]
<Philippa> oh, and ignored anything but the one you're currently trolling about?  [23:02:02]
<Goober> You're obsessed with minor details Philippai my statement was general  [23:02:22]
<Goober> try to be pragmatic  [23:02:29]
<Eduard_Munteanu> vixey, meaning that data will be stored in the minimum amount of space, e.g. like in "in-place sorting algorithms"  [23:02:30]
<vixey> Eduard_Munteanu: geez NP-completei sounds like a _lower_ bound  [23:02:50]
<Philippa> I don't need to try, dear child  [23:02:51]
<Goober> C compilers *practically* translate quite directly to ASM. That's why we code in C!  [23:02:53]
<lilac> Goober: ok, some facts. on /some/ architectures, there's an easy mapping between C and asm. on other architectures, there isn't.  [23:02:57]
<Philippa> and it's distinctly less easy the better your compiler's optimisations are  [23:03:16]
<lilac> even on those architectures where there's an easy mapping, that is usually not the mapping that's used  [23:03:20]
<opqdonut> and in any case, heavy optimizations are taking place
<opqdonut> yes  [23:03:21]
<Axman6> Goober: optimising ones change the code a hell of a lot, they're nowhere direct translations in many cases  [23:03:30]
<Philippa> of course, C itself puts upper bounds on how good an optimiser can bes  [23:03:39]
<Goober> I disagree, Axman6  [23:03:49]
<wchogg> I think part of the problem is that it's not very clear what your initial statement really meant, Goober.  C & Haskell both compile down to ASM.
         What's the distinction between them?  [23:03:52]
<Axman6> o rly?  [23:03:57]
* sw17ch notes that optimizations that try and get the CPU's branch predictor to behave a specific way are hugely wicked and dont map to the C code
  hardly at all  [23:04:01]
<vixey> hm  [23:04:02]
<Eduard_Munteanu> vixey, yes, given a piece of Haskell code, can it be transformed into in-place asm code?  [23:04:06]
<vixey> I think that what I said there does't really make sense  [23:04:09]
<Goober> gcc at O3 on x86 is still a very high correlation  [23:04:10]
<vixey> it shouldn't be NP-complete as a lower bound but NP-hard (?)  [23:04:23]
<Philippa> wchogg: low-level vs high-level, approximately. Of course, the part where you can give clear if boring operational semantics to haskell with
           extremely clear low-level interpretation goes out of the window  [23:04:32]
<lilac> Goober: the extent to which the C source resembles the ASM is the same as the extent to which your language has /prevented/ optimization, in my
        opinions  [23:04:39]
<Philippa> Goober: pull another percentage out of your arse, go on  [23:04:43]
<Axman6> if by high correlation you mean it doed the same thing as the code is supposed to, then yes
<Eduard_Munteanu> vixey, the correct way to say it is "the problem is in NP"  [23:04:58]
<Goober> I spend 4-5 hours a day in Ida Pro
<vixey> Eduard_Munteanu, still not totally sure what you mean, it is possible to compile haskell into assembly thoughi SPJs book has got some info about
        it  [23:05:01]
<Philippa> c'mon, "very high" is the best you can do?
<Goober> Ida has no problem with O3  [23:05:10]
<Goober> it's minor  [23:05:19]
<vixey> @go simon peyton jones implementing functional languages  [23:05:22]
<lambdabot> http://research.microsoft.com/~simonpj/papers/pj-lester-book/  [23:05:25]
<lambdabot> Title: Simon Peyton Jones: book
<vixey> Eduard_Munteanu, the chapters in there about STG are interesting  [23:05:47]
<Eduard_Munteanu> vixey, example: reading a list, modifying it and printing it out again. Can the compiler transform the functional code (which isn't
                 in-place) in asm-code that uses the minimum required storage space, without any hints provided?  [23:06:10]
<kalven> Goober: have you worn out Ezla already?  [23:06:11]
<Axman6> you know, Goober is the first troll i've ever seen in here. never thought they'd know what haskell was  [23:06:28]
<Vq^> Axman6: oh, there has been a few  [23:06:55]
<opqdonut> 1359.43    # Ezla !n=Ezla@cpe-76-172-169-17.socal.res.rr.com has left #Haskell []  [23:06:56]
<Goober> Saying that C corresponds to Asm == trolling  [23:06:57]
<opqdonut> 1706.26 [freenode]    # Goober !n=Goobre@cpe-76-172-169-17.socal.res.rr.com  [23:07:00]
<Philippa> pretty lame troll given that odds are someone's actually learning about haskell implementations here  [23:07:08]
<opqdonut> uncanny resemblance ;)  [23:07:09]
<lilac> Ezla [n=Ezla@cpe-76-172-169-17.socal.res.rr.com]  [23:07:10]
<Goober> That's a really fringe perspective
<quicksilver> Eduard_Munteanu: No.  [23:07:23]
<Axman6> opqdonut: heh  [23:07:32]
<Philippa> nah, using poor strawman arguments to get a rise, that's second-rate trolling  [23:07:36]
<vixey> lilac, hehe  [23:07:40]
<quicksilver> Eduard_Munteanu: well it doesn't anyway. If by 'Can' you're talking about the realm of possibility, then one can imagine it of course.
                                                                                                                                                [23:07:42]
<opqdonut> Ezla was actually pretty good  [23:07:47]
<Eduard_Munteanu> quicksilver, my specific question was: can there exist such an algorithm?  [23:08:13]
<sw17ch> So, i entered before this exchange started, what was his original point?  [23:08:24]
<lilac> Goober: why don't you tell us how great D is?  [23:08:29]
<quicksilver> Eduard_Munteanu: for all code in general, I suspect not.  [23:08:30]
<Eduard_Munteanu> AFAICT, it isn't possible for imperative languages.  [23:08:31]
<sw17ch> I'm assuming it was "C is better than Haskell for reason X"  [23:08:34]
<sw17ch> what was the "X"?  [23:08:38]
<Axman6> Goober: you affraid you'll lose your job to some haskell expert or something? seems you're pretty well invested in C, and you're not liking all
         this news about haskell's awesomeness  [23:08:44]
<quicksilver> Eduard_Munteanu: for various specific programs yes.  [23:08:46]
<lilac> sw17ch: actually, preference hasn't been expressed  [23:08:51]
* paolino wishes to have the standard troll free time to spare in other ways  [23:08:54]
<Philippa> sw17ch: "OMG, Haskell's all high-level and icky, why can't it be low-level like C?"  [23:08:56]
<Eduard_Munteanu> quicksilver, thanks, I see.  [23:08:57]
<Axman6> sw17ch: it was "why isn;t there a low-level haskell like C?" or some such nonsense  [23:09:19]
<sw17ch> Philippa: Haskell is the first High Level language that forced me to understand what it was doign on the low level to be good at it  [23:09:22]
<Goober> Now, your reactions towards " C <m> Asm " lead me to wonder where the overemphasised reactions come from. Do Haskell programmers have some kind
         of "opcode envy" or "C envy" regarding the correlation of their code to machine code?  [23:09:27]
<quicksilver> Eduard_Munteanu: I can't give you a proof but most forms of 'perfect code analysis' will inevitably be halting problem.  [23:09:31]
<lilac> sw17ch: the assertion that "C [s] directly translates into opcodes"  [23:09:34]
<Goober> Why is this such a pronounced negativity on this channel?  [23:09:37]
<Goober> lilac: Not directly  [23:09:46]
<lilac> Goober: that's what you said  [23:09:51]
<Philippa> hell no, the problem's that C's too high-level for good functional language implementations  [23:09:52]
<Goober> I said like 10 times, correlation  [23:09:54]
<Philippa> it's a shite portable assembler  [23:09:58]
<Eduard_Munteanu> quicksilver, no, this can't be reduced to the halting problem, since that is specific to Von Neumann machines (i.e. imperative code).
                                                                                                                                                [23:10:06]
<Axman6> Goober: because you got perfectly reasonable responses to your questions and then started fighting people about their answers, when you were
         wrong  [23:10:12]
<Goober> I'm not wrong.  [23:10:23]
<vixey> Goober, yeah what Philippa said is very a good point  [23:10:25]
<Axman6> yes you are  [23:10:28]
<lilac> "14:50 < Goober> which directly translates into opcodes the same way as C does"  [23:10:30]
<sw17ch> Ah, we're making the claim that C is a portable assembler? Well, maybe with a lot of preprocessor help and typedef helps  [23:10:34]
<fasta> Goober: GHC's generated ASM could be improved for readability, yes.  [23:10:35]
<Eduard_Munteanu> quicksilver, or at least, not without proof.
<quicksilver> Eduard_Munteanu: not it's not. The halting problem applies to all turing complete languages, von neumann style or otherwise.  [23:10:42]
*** paolino (n=paolino@host39-173-dynamic.3-87-r.retail.telecomitalia.it) is now known as Wrong  [23:10:44]
<Goober> lilac: You're hair splitting, my point was clear.  [23:10:58]
<Goober> "the way that C does"  [23:11:08]
<Eduard_Munteanu> quicksilver, sorry, Turing-complete. But my impression is Haskell doesn't qualify as Turing-complete.  [23:11:09]
<vixey> does any analogue of the halting problem apply to non-TC languages?  [23:11:10]
<Goober> implies some degree of "the way"  [23:11:14]
<Philippa> so "not that much, really"?  [23:11:16]
<quicksilver> Eduard_Munteanu: Your impression is wrong.  [23:11:18]
<Axman6> Goober: did you look at GHC.Prim?  [23:11:23]
<quicksilver> Eduard_Munteanu: haskell is very much turing complete.  [23:11:25]
<vixey> Eduard_Munteanu, haskell isn't Turing Complete m it's General Recursive :)  [23:11:33]
<Goober> Answer my question  [23:11:34]
<lilac> Goober: sure, but the argument here was that degree is not that great  [23:11:37]
<Goober> Why are Haskell programmers so angry about this?  [23:11:41]
<Axman6> no of course not, because you're not here to listen, you're here to moan about things you don't know about  [23:11:47]
<lilac> Goober: the only anger i've sensed here was from you  [23:11:51]
<Eduard_Munteanu> quicksilver, how does something like "list = [1i]" qualify as a statement from a Turing-complete language.  [23:11:54]
<Eduard_Munteanu> ?  [23:11:55]
<Philippa> we answered your original question. You seized on the answer you didn't like. Terrible shame, really  [23:12:01]
<Philippa> I mean, talk about showing your hand early  [23:12:07]
<Goober> lilac: No, if we discuss the correspondence of Asm <-> C on other channels, there's a different perspective  [23:12:14]
<Goober> this is unusual here  [23:12:19]
<vixey> Eduard_Munteanu, (These two computational classes are equivalent)  [23:12:20]
<quicksilver> Eduard_Munteanu: "turing-complete" and "statement" are unrelated.  [23:12:22]
<opqdonut> Eduard_Munteanu: look at it this way: you can implement a turing machine in haskell  [23:12:23]
<Goober> you guys have Opcode envy  [23:12:26]
<Axman6> o.O  [23:12:32]
<Axman6> what a nutjob  [23:12:36]
<opqdonut> :D  [23:12:37]
<quicksilver> Eduard_Munteanu: "turing complete" is about whether or not you can compute all computable functions.  [23:12:40]
<orbitz> is Goober still upset Haskell isnt' D  [23:12:45]
<vixey> Goober, There's various abstract machines for lazy evaluation s  [23:12:53]
<Philippa> hell, Goober's only in here because it's getting scarily easy to write haskell that performs as well as or better than C anyway  [23:13:21]
<lilac> Goober: as far as i can see, no-one here has argued that, for instance, GHC translates Haskell to x86 asm more faithfully than GCC translates C
        to x86 asm  [23:13:25]
<Axman6> Goober: Haskell programmers in general don't give a shit about how the machine handles their code, they just hope it'll be fast, and it often
         is.  [23:13:35]
<orbitz> Philippa: amen!  [23:13:37]
<Philippa> I don't think we're the ones with envy issues, somehow
<Axman6> we use haskell because we don't want to have to think like machines  [23:13:44]
<kalven> :P  [23:14:08]
<lilac> Goober: the answer to your original question is, it's impossible to design a language which corresponds directly to all hardware, since hardware
        differs  [23:14:19]
<lilac> Goober: and if haskell corresponded exactly to, say, x86, it wouldn't be haskell any more  [23:14:39]
<Goober> lilac: Of course  [23:14:41]
<Goober> I didn't argue that  [23:14:46]
<Eduard_Munteanu> opqdonut, quicksilver, but isn't it true that in Haskell you can compute things you can't compute on Turing machines?  [23:14:52]
<Goober> I simply made a reasonable analog  [23:14:54]
<opqdonut> Eduard_Munteanu: no  [23:15:00]
<Axman6> no, you didn't  [23:15:01]
<vixey> Eduard_Munteanu, *AHEM* (These two computational classes are equivalent)  [23:15:02]
<Philippa> and you got an answer: "it's like this because otherwise it couldn't be what it is"  [23:15:08]
<Philippa> funny how you ignored that one  [23:15:12]
<vixey> Eduard_Munteanu, missing all my remarkss
<Axman6> no one here is sure what your point is  [23:15:13]
<opqdonut> Eduard_Munteanu: as you could write a haskell interpreter for a turing machine  [23:15:15]
<Goober> Axman6: Saying that C translates to Asm is very reasonable.  [23:15:21]
<opqdonut> Eduard_Munteanu: because the computer you are currently running haskell on is practically a turing machine  [23:15:32]
<Axman6> that wasn;t what you were talking about originally. ands who cares?  [23:15:41]
<lilac> Goober: that's just saying that C can be compiled. beyond that it's a question of degree  [23:15:42]
<Goober> Fine  [23:15:50]
<Axman6> i don't care what my haskell looks like in asm  [23:15:53]
<Goober> *relatively high degree*  [23:15:56]
<Axman6> doesn't matter one bit to me, as long as it runs ok, i'm happy  [23:16:10]
<Goober> particularly because of the mannerisms of "call", push and pop  [23:16:13]
<quicksilver> Eduard_Munteanu: basically the argument is as follows : you can write a turing machine in haskell; you can write a haskell interpreter in a
              turing machine.  [23:16:19]
<Goober> many of the C language ideas match up with Asm in the first place  [23:16:25]
<quicksilver> Eduard_Munteanu: therefore the two have equivalent computability power.  [23:16:32]
<opqdonut> Goober: yes, C is an imperative language  [23:16:38]
<Axman6> Goober: what's your point?  [23:16:39]
<quicksilver> Eduard_Munteanu: (substitute 'your favourite language' for haskell too)  [23:16:48]
<Philippa> Goober: except that C won't let you manipulate the stack directly, and many compilers do their best to find other ways to handle function
           calls when they can  [23:16:50]
<lilac> Goober: i'd agree, having looked at both, that GCC's C compiler often produces asm which is more similar to the C code than the asm produced by
        GHC  [23:17:06]
<lilac> Goober: but why do i care?  [23:17:14]
<Eduard_Munteanu> quicksilver, err, while you can write a Turing machine in Haskell, writing Haskell on a Turing machine misses a few things, for example
                 you can define infinite stuff, but not actually "iterate" it.  [23:17:25]
<Eduard_Munteanu> Is this correct?  [23:17:28]
<Axman6> i'd be a interested in seeing functional ASM  [23:17:29]
<lilac> also, that doesn't mean these are inherent properties of C or Haskell  [23:17:30]
<Goober> Axman6: The fact that asm is inclusive of C's paradigm is a large contributor towards the level of correlation  [23:17:35]
<vixey> Eduard_Munteanu, "iterate"?  [23:17:49]
<Goober> asm is not inclusive of Haskell's paradigm  [23:17:50]
<Axman6> Goober: so what? i still can't see your point  [23:17:58]
<quicksilver> Eduard_Munteanu: no, it's not correct.  [23:18:00]
<Goober> The point is  [23:18:02]
<Eduard_Munteanu> vixey, you can define an infinite list, but not actually store it on a Turing machine.  [23:18:09]
<Goober> *C CAN BE REPRESENTED IN ASM* directly
<Goober> Haskell cannot  [23:18:14]
<Axman6> ok? so?  [23:18:15]
<quicksilver> Eduard_Munteanu: you can't *actually* store an infinite list in haskell either.  [23:18:26]
<Axman6> why do i care?  [23:18:32]
<lilac> Goober: for certain values of asm, i agree. so what?  [23:18:34]
<Philippa> Sure. You've got to flatten Haskell's declarations first. Once you've lambda-lifted it's not that much further away than C, though  [23:18:40]
<quicksilver> Eduard_Munteanu: (obviously that would use infinite space)  [23:18:44]
<Philippa> it's just that nobody wants that implementation  [23:18:45]
<vixey> In some interpretation, you can store an infinite lists  [23:18:47]
<lilac> Goober: also, for certain values of 'directly'  [23:18:55]
<vixey> the encoding is programatic though  [23:19:01]
<Eduard_Munteanu> quicksilver, isn't "storing" in Haskell just a definition? I mean, it's only referential.  [23:19:05]
<quicksilver> Eduard_Munteanu: however you can work with an representation of an infinite list using laziness, just as you can in a turing machine.
                                                                                                                                                [23:19:08]
<Philippa> lazy evaluation is just another calling convention  [23:19:09]
* sw17ch ponders how one would write a C  ->  JavaScript compilers  [23:19:17]
<Goober> I think that's the point you guys missed from my original statementsi the fact that C can be represented in Asm, and that optimization is a
         further mangling of such a direct rep  [23:19:18]
<vixey> as opposed to malloc(length * sizeof(element))  [23:19:19]
<Philippa> Axman6: consider the relationship between jumps and CPS :-)  [23:19:23]
<lilac> Philippa: depends what you mean by 'calling convention' really  [23:19:34]
<quicksilver> Eduard_Munteanu: you can choose what 'store' meant. In that context it sounded like you meant store physically on the tape, which is why I
              gave a physically motivated answer.  [23:19:45]
<Axman6> Philippa: yep, i love me my CPSs what's CPS?
<Axman6> Goober: why would i want haskell to be like ASM?  [23:20:01]
<lilac> Philippa: i'd say it's a /slight/ generalization of the usual concept to include laziness, but only slight  [23:20:05]
<Philippa> Goober: it's more that the mapping's not all that useful unless you run with the optimiser off all the time. Not to mention that there are
           subsets of Haskell that do map cleanly  [23:20:09]
<Goober> Axman6: I never said you'd want Haskell to be like Asm  [23:20:17]
<Goober> I never said anything like that  [23:20:22]
<lilac> Philippa: since it also affects how you use the return value, and not just how you call the function  [23:20:24]
<Philippa> or at least, as cleanly as C ever does
<Goober> My original question, wass  [23:20:27]
<StoneToad> sw17ch: well, one could write a generic asm interpreter in JS, and then just compile the C to asm  [23:20:33]
<vixey> Axman6: You don't know CPS yet? :)  [23:20:34]
<Goober> "Can there be a low level haskell"  [23:20:35]
<Philippa> yes. And you got an answer right at the start  [23:20:43]
<Axman6> vixey: nope
<Goober> which translates directly to asm the way that C does  [23:20:44]
<lilac> Goober: if you recall, vixey answered that  [23:20:53]
<Philippa> "no"
<Eduard_Munteanu> quicksilver, storing == represent. I like to thing there is such a thing like a "Haskell machine" that can "iterate over" (e.g. print)
                 or "store" infinite lists.
<Eduard_Munteanu> s/thing/think  [23:20:57]
<quicksilver> Eduard_Munteanu: Yes.  [23:20:58]
<quicksilver> Eduard_Munteanu: you can do that in a turing machine too.  [23:21:02]
<Philippa> there are significant subsets that there can be, but it'd be a haskellm  [23:21:04]
<Axman6> Goober: no. now, go look at GHC.Prim and see how close you can get, ok?  [23:21:06]
<Eduard_Munteanu> quicksilver, yeah, but the Turing machine won't halt.  [23:21:15]
<quicksilver> Eduard_Munteanu: wrong.  [23:21:21]
<vixey> Axman6: It's a form for programs so that everything takes a continuation m and plugs its result into that continuation instead of 'returning'
                                                                                                                                                [23:21:23]
<wchogg> Phillippa:  Gahsso what I meant earlier was that I wasn't clear on what the point of this discussion was supposed to be, what Goober wanted to
         understand.  If it's just the fact that Haskell has semantics that require trickier compilation techniques than C, then so what?  [23:21:26]
<Philippa> of course, it wouldn't have been a good trolling run if you'd paid attention to that answer now, would it?
<Axman6> vixey: where should i have learnt it?  [23:21:27]
<quicksilver> Eduard_Munteanu: any particular haskell program which uses infinite lists to produce a finite result, can be encoded on a turing machine.
                                                                                                                                                [23:21:41]
<StoneToad> Eduard_Munteanu: anything dealing with an infinite output won't terminates  [23:21:54]
<quicksilver> Eduard_Munteanu: (come to that, any haskell program which doesn't halt can also be encoded as a non-halting turing machine program!)
                                                                                                                                                [23:21:55]
<Goober> lilac: vixey answered nothing  [23:22:02]
<vixey> Axman6: here's an example of a program in CPS http://hpaste.org/12697#a5  [23:22:06]
<Eduard_Munteanu> quicksilver, I see.  [23:22:11]
<lilac> Axman6: CPS means that your function, instead of returning a value, takes a function which consumes the return value as an argument.  [23:22:19]
<Goober> he had no interest concept or insight, he just said "whatever"
<orbitz> Goober: are you just pointing otu that C maps somewhat more idrectly to ASM (depending on the ASM), or are you makign some sort of value
         judgemetn abed off that?  [23:22:25]
<Philippa> sure, vixey isn't the person I'd ask about low-level behaviour. OTOH, vixey wasn't the only person to answer  [23:22:31]
<Philippa> oh, and I think you'll find that's "she"  [23:22:49]
<Axman6> lilac: oh, ha, right. i'm getting strange cannibalistic function images in my head now :)  [23:22:53]
<Goober> I won't ask him in the future, because she proved herself to be a newbie.  [23:22:56]
<Goober> her him she whatever :)  [23:23:04]
<orbitz> newbie in what?  [23:23:14]
<vixey> Axman6: (Don't know any good reference, avoid wikipedia though)
<Eduard_Munteanu> quicksilver, but for the sake of computational theory, can't we imagine a Haskell machine that (1) doesn't handle imperative code and
                 (2) always halts, no matter what infinite input is told to process?  [23:23:21]
<sw17ch> @karma vixey  [23:23:26]
<vixey> I'm thinking about writing a short thing about it, to learn some TeX  [23:23:28]
<sw17ch> @bot  [23:23:40]
<lunabot>  :)  [23:23:41]
<Axman6> vixey: now that is another language well worth learning :)  [23:23:46]
<Eduard_Munteanu> quicksilver, I mean, is this a consistent machine?  [23:23:50]
<lilac> Goober: orly? you: "why can't there be a low level haskell?" her: "there already is" you: "raah i know better"  [23:23:52]
<Axman6> lambdabot: oi!  [23:23:55]
<Goober> Orbitz: I was wondering if there could be a subset of Haskell which * can be represented directly in Asm * with a relatively same level of
         correspondence as C can be
<Axman6> , karma vixey  [23:24:00]
<lunabot>  luna: Not in scope: `karma'  [23:24:08]
<Axman6> preflex: karma Philippa  [23:24:09]
<preflex>  karma for Philippa: 1
<lilac> Goober: whether the answer to your question is yes or no depends entirely on what you consider to still be haskell  [23:24:13]
<Axman6> preflex: karma vixey
<preflex>  karma for vixey: 9
<orbitz> Goober: i beleivei Philippa said that after one does lambda lifts on haskell code you get something very close  [23:24:18]
<Axman6> p and v are right next to each other >_>  [23:24:24]
<lilac> Goober: had you asked further rather than getting angry, you could have learnt about what the already-existing thing was  [23:24:39]
<Goober> After the lambda liftse e  [23:24:47]
<orbitz> Goober: is this sort of attribute particularly useful for some reason or are you just curious?  [23:24:48]
<Goober> lilac: what's the already existing thing?  [23:24:53]
<quicksilver> Eduard_Munteanu: in your mind there seems to be some connection between imperative code and not halting.  [23:24:56]
<quicksilver> Eduard_Munteanu: there honest isn't.  [23:25:00]
<Axman6> Goober: i think i remember reading about a language that aimed to do that recently  [23:25:02]
<quicksilver> Eduard_Munteanu: "last [0i]" is a non-halting program. No imperative work there.  [23:25:12]
<lilac> Goober: i don't know, but i recall there being a low-level haskell variant designed for writing embedded software with  [23:25:24]
<quicksilver> Eduard_Munteanu: notions of turing computation are inherently about computing numbers and so are very pure and functional.  [23:25:36]
<orbitz> lilac: Timber?  [23:25:38]
<Goober> lilac: I'd like to know the name if you remember  [23:25:40]
<Philippa> Goober: after the lifts, it's just ordinary code for a GCed language - you need a representation for higher-order functions and you need a way
           of handling laziness, but closures and thunks handle that neatly  [23:25:41]
<wchogg> lilac:  I know there is current work on such things.  [23:25:42]
<sw17ch> Cm is a good portable assembler  [23:25:59]
<Philippa> the intermediate languages for languages like haskell and those in vogue for languages like C are surprisingly closely related  [23:26:05]
<Eduard_Munteanu> quicksilver, yeah, I imagine any imperative code in a statement = statement(time) manner, so infinite data leads to infinite statements
                 which lead to no halting.  [23:26:15]
<Philippa> (for the haskellers: we're talking STG, not Core)
<Axman6> anyone remember that functional language that aimed to correspond to hardware types quite closely?  [23:26:28]
<sw17ch> perhaps one could consider LLVM a portable assembler as well  [23:26:30]
<orbitz> Philippa: STG?  [23:26:33]
<Eduard_Munteanu> quicksilver, gotta read more of that, sorry.
<Axman6> bitsomething maybeh  [23:26:35]
<Eduard_Munteanu> quicksilver, I know some basics.  [23:26:46]
<vixey> Eduard_Munteanu: You know the definition of Turing Complete?  [23:26:50]
<Axman6> speaking of LLVM, could it be used to improve GHC at all?  [23:26:58]
<orbitz> Goober: is a correspondence to ASM a useful attribute of a language you are interested in or are you just curious?  [23:27:13]
<Philippa> orbitz: "Spineless Tagless G-Machine". One of GHC's intermediate languages  [23:27:16]
<quicksilver> Eduard_Munteanu: let x = x + 1 in x is another non-halting program, if you want to avoid infinite data.  [23:27:18]
<Eduard_Munteanu> vixey, a Turing machine. It processes code and data sequentially.  [23:27:25]
<vixey> Eduard_Munteanu: There's also a definition of General or Mu-recursive functionsm Haskell fits _this_ definition  [23:27:38]
<quicksilver> Eduard_Munteanu: basically unrestricted recursion or unrestricted looping allows you to write non-halting code.  [23:27:39]
<Goober> orbitz: curious  [23:27:48]
<alar> is it possible to say "instance MyColl PriorityQ" instead of "instance MyColl (PriorityQ k v) k v"?  [23:27:49]
<orbitz> Philippa: is it a cowardly language?  [23:27:53]
<quicksilver> Eduard_Munteanu: and yet, unrestricted recursion and unrestricted looping are known to be required for turing completeness.  [23:28:06]
<vixey> Eduard_Munteau, It turns out these two classes are equivalent (like I saidi)
<Goober> How do you guys "judge" GHC's output?  [23:28:19]
<quicksilver> alar: only in the associated types version.  [23:28:22]
<Eduard_Munteanu> Oh, I understand.  [23:28:25]
<Goober> I judge my GCC's output.  [23:28:26]
<orbitz> Goober: okay.  i think as you learn haskell you'll see beign close to ASM is not a particualrly useful attribute of a language as well
                                                                                                                                                [23:28:27]
<Philippa> orbitz: heh. Totally. Not as lazy as Haskell, though  [23:28:28]
<vixey> so I think it's not useful to think about haskell as "turing complete"  [23:28:30]
<sw17ch> Goober: with a stopwatch and the size of the binary?  [23:28:44]
<vixey> this is just a consequence of some mathematical nonsense that you don't need when programming  [23:28:47]
<Philippa> quicksilver: the untyped lambda calculus has neither ;-)  [23:28:53]
<Goober> sw17ch: But in the asm, are haskell programmers truly blind?  [23:29:08]
<Eduard_Munteanu> quicksilver, my judgement came from the consideration that there could be a Haskell machine that can process such infinite inputs and
                 always halt.  [23:29:10]
<Goober> there must be a way to judge it  [23:29:12]
<vixey> what is interesting is that any general recursive function is expressible in haskell *directly*  [23:29:13]
<quicksilver> alar: that is, essentially, the advantage of the AT version.  [23:29:14]
<sw17ch> Goober: you could stop by insulting us  [23:29:16]
<quicksilver> Goober: I judge it by whether it does the task I wanted it to do.  [23:29:23]
<fasta> Goober: most people don't care. You are thinking about security probably.  [23:29:24]
<Goober> sw17ch: that's not an insult  [23:29:26]
<Goober> it's a metaphor  [23:29:29]
<quicksilver> Goober: correctly, and in an acceptable time.  [23:29:30]
<orbitz> Goober: what do you mean by judging it?  [23:29:38]
<Eduard_Munteanu> But I see that this is my definition only.
<alar> quicksilver: and all this type-family stuff is just for this?  [23:29:44]
<Philippa> Goober: like I said, some subsets map fairly cleanly and others don't. In practice, people want an aggressively optimising compiler and GHC
           does things GCC could barely dream of  [23:30:00]
<quicksilver> Philippa: untyped lambda calculus has unrestricted recursion, effectively, just not as an explicit syntax.  [23:30:03]
<quicksilver> alar: not at all.  [23:30:13]
<Philippa> quicksilver: or a concept in the language :-)  [23:30:16]
<quicksilver> alar: it's for a whole bunch of struff  [23:30:20]
<quicksilver> Philippa: agreed.  [23:30:22]
<fasta> Goober: or at least, they don't care enough to push patches to GHC.  [23:30:23]
<quicksilver> alar: but that is its effect on your simple example.  [23:30:33]
* sw17ch ponders how being called "truly blind" is a metaphor, not an insult  [23:30:39]
<Goober> orbitz: For example, I compile my O3 code in GCC, I make sure to include debug symbols so that non-inlined procedures are easy to find, and I
         produce an output which (in OllyDbg) very nicely aligns the source code alongside my C++ code. Then I "pass judgement" on how good GCC did.
                                                                                                                                                [23:30:52]
<Eduard_Munteanu> quicksilver, vixey, thanks.  [23:30:53]
<Goober> That's what I mean.  [23:30:55]
<Goober> I'll show an example:  [23:30:58]
<Philippa> sw17ch: hell, there's a good argument for the metaphor being ablist  [23:31:00]
<fasta> Goober: for some inner loops one can see what's going on with quite some effort.  [23:31:09]
<fasta> Goober: now, find a different topic :)  [23:31:28]
<orbitz> Goober: so you are judging it based on how well the executable aligsn with yoru sorucecode?  [23:31:43]
<sw17ch> My haskell aligns with source code just fines  [23:31:57]
<Eduard_Munteanu> Although I wonder if there is such a thing like a truly functional CPU (no emulation).  [23:32:11]
<Goober> http://img530.imageshack.us/img530/9948/xxx1iq9.png  [23:32:13]
<sw17ch> you can even tell which functions the ASM comes from!  [23:32:16]
<Goober> Notice the "code column"  [23:32:17]
<Goober> Having a code column works *even in O3*  [23:32:26]
<Goober> you can see the procedure being repeated  [23:32:33]
<quicksilver> Goober: very few people that I have spoken to bother to analyse their haskell code in that detail.
<Goober> at each inlining spot  [23:32:38]
<quicksilver> Goober: having said that, very few people analyze their C in that detail  [23:32:45]
<quicksilver> (although evidently you do)  [23:32:48]
<orbitz> Goober: you judge this as good?  [23:32:50]
<wchogg> Eduard_Munteanu:  Maybe the old lisp machines were closer?  [23:32:55]
<quicksilver> dons analyses haskell ASM output.  [23:32:56]
<Goober> orbitz: This is unoptimized  [23:33:01]
<quicksilver> and obviously the guys who write the codegen do.  [23:33:05]
<orbitz> ok  [23:33:06]
<Goober> orbitz: its easy to read  [23:33:08]
<Goober> for the example  [23:33:12]
<Eduard_Munteanu> wchogg, Lisp machines? That's gotta be something. /me googless  [23:33:22]
<Philippa> Goober: Haskell's concrete syntax isn't particularly amenable to that particular way of comparing. Effectively you have to think through a
           couple of layers of translation  [23:33:28]
<orbitz> Goober: i'm afraid i don't see the poitn very much.  unless you are writing a haskell optimizers  [23:33:35]
<vixey> Axman6, saw the CPS example?  [23:33:46]
<Goober> orbitz: it's just a "habit"  [23:33:51]
<Axman6> Goober: ASM is inherently imperative right?  [23:33:54]
<Philippa> mostly that's due to the fact functions are first-class  [23:34:00]
<Axman6> vixey: yep  [23:34:03]
<Goober> axman6: the asm itself is, not the code it represents.  [23:34:13]
<daf> assembler is dull  [23:34:23]
<orbitz> Goober: being a habit doesn't make it useful  [23:34:25]
<Axman6> it is with C
* sw17ch goes to find dons' blog  [23:34:33]
<solrize_> @src (&&)  [23:34:39]
<Goober> The ASM in my screenshot does *exactly* what the C code does on the right side  [23:34:47]
<Axman6> @go don steward blog  [23:34:53]
<Axman6> Goober: so?  [23:35:03]
<alar> Goober: that means your C compiler optimizes poorly  [23:35:10]
<orbitz> Goober: i'm not seeing the connection between that being true and that being valuable  [23:35:17]
<Axman6> Cale: lambdabot needs a restart again  [23:35:18]
<Eduard_Munteanu> wchogg, yeah, though it seems the underlying hardware still maintains some imperative flavor.  [23:35:37]
<alar> @bot  [23:35:41]
<lunabot>  :)
<sw17ch> Goober: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast  [23:35:42]
<Axman6> orbitz: which is what i've been trying to say, but failing. well put  [23:35:45]
<Philippa> orbitz: it has some value if you want to tweak the compiler into producing specific output. Of course, so do things like GHC's inline function
<sw17ch> dons goes over a bunch of stuff about haskell code generation there and strictness analysis  [23:36:03]
<Goober> Well, if I code in Haskell, I want to know how I will avoid my OCD habit of reading Asm  [23:36:10]
<Goober> it's difficult not to do it  [23:36:13]
<orbitz> Philippa: i feel like Goober is trying to get at something elses  [23:36:15]
<sw17ch> Goober: you can read it, i read mine  [23:36:22]
<orbitz> Goober: habits ca nbe broken in 14 days, just obstain  [23:36:29]
<Goober> I dont wanna abstain  [23:36:37]
<alar> Goober: what OS do you write for?  [23:36:40]
<Goober> windows  [23:36:45]
<solrize_> Eduard_Munteanu - look for "reduceron"  [23:36:52]
<orbitz> Goober: then you don't want to avoid your OCD, so your initial statement is false  [23:36:55]
<alar> you're lucky  [23:36:58]
<salty-horse> hi. question: do parentheses have any meaning in function signatures? or are they added just for readability? I'm trying to understand the
              return value of liftP (linked) and it only makes sense when I "expand" the type InfoP and remove the parentheses around its
              http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html#find.predicate.lift  [23:36:59]
<Goober> orbitz: explain?  [23:37:04]
<alar> in unices Asm is so obscure that I can't even find decent debugeer  [23:37:21]
<orbitz> Goober: you just said "I want to know how I will avoid my OCD habit", then you said "But i dont' want to abstain", so you don't want to avoid
         your habit  [23:37:26]
<Goober> alar: No  [23:37:28]
<Goober> that's only AT&T syntax  [23:37:32]
<vixey> salty-horse, (a -> b) -> c  is different to  a -> (b -> c)  [23:37:33]
<orbitz> Goober: feelf ree to compare ASM to haskell, i jus may not be informative, but nothign will stop you  [23:37:44]
<Goober> you can output/convert to Intel/Masm syntax  [23:37:46]
<Philippa> orbitz: people have conflicting desires, that's nothing new  [23:37:55]
<alar> Goober: what syntax? I;m talking about debugger program  [23:38:06]
<Eduard_Munteanu> solrize_, whoa, great stuff. Still, gotta read those papers and see what it does exactly.  [23:38:12]
<Goober> Just use NASM  [23:38:15]
<alar> is there TD for *NIX?  [23:38:16]
<orbitz> Philippa: i just pion them out, don't claim revelation :)  [23:38:18]
<Goober> Nasm is highly readable  [23:38:19]
<vixey> salty-horse, (a -> b) -> c  means it takes a function 'a -> b' to a 'c', whereas a -> b -> c means it takes an 'a' and a 'b' to a 'c'  [23:38:25]
<alar> yes, NASM all the way, but what I will debug it with?  [23:38:40]
<Philippa> orbitz: you made the leap from "want X" to "don't want ö½¯" though  [23:38:54]
<salty-horse> vixey, ok. can you explain liftP then? it's supposed to return a function (InfoP c). but instead, that function's arguments are part of
              liftP's parameters  [23:38:57]
<salty-horse> vixey, (at least to my understanding)  [23:39:12]
<quicksilver> salty-horse: it specifies the function it returns by defining what it does, with its parameters  [23:39:27]
<Eduard_Munteanu> salty-horse, you should look at what "currying" means.  [23:39:32]
<Eduard_Munteanu> It's quite handy to understand typing.  [23:39:46]
<quicksilver> Eduard_Munteanu: no, he shouldn't.  [23:39:49]
<Philippa> orbitz: compare and contrast with intuitionistic logic :-)  [23:39:51]
<quicksilver> salty-horse: it could have been written "liftP q f k w = \x y z -> f w x y z `q` k"  [23:40:12]
<salty-horse> Eduard_Munteanu, I understand curryingi this is a bit different.. should I start by expanding the type InfoP into its original definition?
                                                                                                                                                [23:40:14]
<salty-horse> Eduard_Munteanu, (I think :D)  [23:40:25]
<orbitz> Philippa: I'm human too, can't I be illogical in my logical analysis?!  [23:40:30]
<Eduard_Munteanu> quicksilver, why? Only after I got what curry means I could understand what types really mean.
<Goober> On thing to think about, regarding Haskell <-> ASM. Have you guys ever coded in a Macro assembler?  [23:40:31]
<quicksilver> salty-horse: which would be "more obviously" a function which takes four parameters returning a function which takes three.  [23:40:35]
<quicksilver> salty-horse: is that what you would have expected?  [23:40:49]
<alar> Goober: have you ever tried typeful asm?  [23:41:03]
<Goober> Have you ever worked with ObjectAsm for example ?  [23:41:10]
<Philippa> orbitz: sure, just don't expect to get away with then implying it's valid by stating the conclusion as a fact :-)  [23:41:22]
<Axman6> Goober: have you done much Haskell yet?
<Axman6> s/done/written  [23:41:30]
<Goober> it's a serious question  [23:41:34]
<Eduard_Munteanu> Many things go as a -> b -> c -> d, though this really means (a, b, c) -> d
<orbitz> Axman6: ohh beat me too it  [23:41:35]
<salty-horse> quicksilver, I don't understand is how liftP has 7 parameters when it should have only 3 according to the signature  [23:41:37]
<Philippa> Goober: as with most things, some #haskellers have and some haven't  [23:41:44]
<Goober> justs answer ;)  [23:41:45]
<Goober> Ok, if you didnt work with a macro assembler, I'll give an example:  [23:42:02]
<Axman6> Goober: i'm just curous, not trying to fight or anything :)  [23:42:03]
<quicksilver> salty-horse: because "InfoP c" itself means another 3 parameters.  [23:42:05]
<quicksilver> salty-horse: did you see my alternative way of writing it?  [23:42:21]
<alar> @where paste  [23:42:30]
<Philippa> you can safely assume that most are familiar with some form of macro system, and there're only so many ways it could work with asm  [23:42:42]
<quicksilver> salty-horse: the key point here is that a haskell function which takes two parameters is also a haskell function which takes one parameter
              s but returns a function which takes one more.  [23:43:03]
<quicksilver> salty-horse: so, a haskell function which takes 4 params and returns a function which takes 3, is the same thing as a haskall function
              which takes 8.  [23:43:24]
<quicksilver> salty-horse: 7. sorry. typo.  [23:43:27]
<Wrong> @paste  [23:43:39]
<alar> @bot  [23:43:49]
<lunabot>  :)
<Goober> K, check here, from MASM32's macros  [23:43:56]
<Goober> http://rafb.net/p/G0wWN017.html  [23:43:57]
<Axman6> lambdabot's dead atm :\  [23:43:58]
<Axman6> Goober: have you written any haskell yet?  [23:44:08]
<Axman6> argh, that's really ugly!  [23:44:41]
<Goober> Yes, pretty ugly.  [23:44:46]
<Goober> Now, the core point I've been leading up to.  [23:44:55]
<orbitz> Goober: anyways, what's the punch-line of you question  [23:44:59]
<lilac> Goober: my guess would be that a few people here have written compilers, some people here have written assembler of some flavour, and more here
        can read assembler of some flavour  [23:45:06]
<Goober> This can be done, in Haskell, with perfection.  [23:45:08]
<Goober> Because Haskell's type system is what they were trying to achieve with the macro assemblers  [23:45:26]
<daf> what's "This"?  [23:45:37]
<Goober> Yet Haskell has the intermediate layer of compiling  [23:45:42]
<Goober> Rather than *being the assembler*  [23:45:47]
<Axman6> again, so?  [23:45:55]
<Goober> being the assembler isnt all that far of a stretch  [23:45:57]
<Philippa> yes. People do actually do such things with it, in fact  [23:46:06]
<sw17ch> we're getting a code generator soons  [23:46:07]
<Goober> Axman6: It would allow perfect code generation  [23:46:08]
<orbitz> Haskell is more than it's type system though, isn't it?  [23:46:11]
<Philippa> in fact, look at Harpy  [23:46:14]
<sw17ch> Goober: "perfect" ?  [23:46:17]
<lilac> Goober: last i checked, gcc goes via two intermediate languages, and gcc-with-llvm goes via three  [23:46:21]
<Philippa> it's a run-time assembler library  [23:46:24]
<Axman6> Goober: would it hinder things like STM, concurrency, and parallelism in haskell?  [23:46:33]
<Philippa> Axman6: humungously  [23:46:44]
<alar> Goober: it's simple  [23:46:47]
<alar> authors just don't want to implement every and each of typesystem extensions in macros  [23:46:48]
<Philippa> it'd require fixed semantics for everything  [23:46:52]
<Goober> Axman6: No, you'd be using Haskell's type system as a macro system.
<Axman6> i don't thing there's an easy asm translasion for a `par` b s  [23:46:55]
<Goober> it harms only what you choose to do with it  [23:47:02]
<Goober> Axman6: Ah, becauses  [23:47:22]
<sw17ch> Axman6: there's not an easy asm translation for let x = 1 : x  [23:47:25]
<Goober> there's no standard library of abstractions  [23:47:33]
<sw17ch> (or maybe there is)  [23:47:34]
<lilac> sw17ch: it depends what you think that means i guess :)  [23:47:39]
<Goober> The "compiler" can be a library  [23:47:48]
<fasta> Axman6: in 10 years there will be.  [23:47:49]
<sw17ch> lilac: how about we say no "obvious" representation  [23:47:51]
<Goober> rather than a honking codebase  [23:47:52]
<Axman6> fasta: let's hope so  [23:48:04]
<Philippa> Goober: same difference
<Philippa> in fact, the compiler /is/ a library  [23:48:06]
<Goober> It's not quite the same Philippa  [23:48:12]
<fasta> Axman6: I see it as a disadvantage personally.  [23:48:15]
<Eduard_Munteanu> quicksilver, http://en.wikipedia.org/wiki/Functional_programming#Recursion (last paragraph)  [23:48:42]
<lilac> sw17ch: in C++, you might say "List<Int> x(new Int(1), &x);" m that has a reasonable translation into x86, but is less lazy than your code
                                                                                                                                                [23:48:47]
<fasta> A computer should export just the primitives.  [23:48:49]
<Goober> You cannot write new GHC optimizations in the form of a simple extension library  [23:48:56]
<Axman6> Goober: what i want to be able to do is say a `par` b + a and have a and b evaluated at the same time, and i don't think anything that is that
         close to ASM would let me do that  [23:48:59]
<Eduard_Munteanu> It describes functional languages that fail to be compatible with Turing machines  [23:49:01]
<Philippa> actually, you can
<Goober> There just *IS* ghc  [23:49:06]
<quicksilver> Eduard_Munteanu: indeed. That's not because they're functional, though.  [23:49:16]
<Goober> there isn't Mr.LeetThunderX's Optimizations Lib  [23:49:21]
<quicksilver> Eduard_Munteanu: it's because they're total.
<lilac> Goober: actually, in 6.10, you /can/ write new GHC optimizations as a simple library  [23:49:33]
<Goober> with the GHC model, you have to have one.  [23:49:34]
<Goober> Not legos.  [23:49:38]
<quicksilver> Eduard_Munteanu: it happens that people who study these things tend to work in a functional setting.  [23:49:48]
<Philippa> Goober: got news for you, enabling that was a Summer of Code project this year  [23:49:49]
<lilac> Goober: you should check your facts
<Goober> LINK  [23:49:58]
<Axman6> lilac: obviously you're a liar  [23:49:59]
*** edwardk_ (i=c72ec6e6@gateway/web/ajax/mibbit.com/x-a2ad1c09c42e44b3) is now known as edwardk  [23:50:03]
<Axman6> Goober said so  [23:50:09]
<lilac> Goober: plus theres {-# RULES s #-} pragmas which have been aroudn for longer  [23:50:10]
<Eduard_Munteanu> quicksilver, can you point me to some information source? I can't find a definition on wikipedia for "total programming language"
                                                                                                                                                [23:50:14]
<Philippa> Goober: google "summer of code" haskell 2008 and dig it up yourself  [23:50:16]
<quicksilver> Goober: you have been able to write quite wide-ranging GHC optimisations as RULES pragma.  [23:50:18]
<Philippa> for a very long time  [23:50:26]
<quicksilver> Eduard_Munteanu: a total programming language is one for which every program terminates in finite time.  [23:50:32]
<Philippa> fusion for a number of datatypes /has/ been supplied as an ordinary library  [23:50:41]
<Goober> quicksilver: Is it good?  [23:50:45]
<Goober> polished?  [23:50:48]
<quicksilver> yes, it's awesome.  [23:50:49]
<Eduard_Munteanu> quicksilver, thanks.  [23:50:51]
<quicksilver> you should read the stream-fusion paper.  [23:50:55]
<orbitz> Goober: you might benefit from learnign haskell  [23:50:58]
<Axman6> @check \xs -> (reverse.reverse) xs == xs  [23:50:59]
<sw17ch> I <3 Stream Fusion  [23:51:05]
<Eduard_Munteanu> quicksilver, where can I find some computational theory about this stuff?  [23:51:07]
<alar> where should I put default implementation for a class methods? In class definition?  [23:51:12]
<quicksilver> Goober: http://www.cse.unsw.edu.au/~dons/papers/stream-fusion.pdf  [23:51:16]
<Goober> quicksilver: thx  [23:51:25]
<quicksilver> Eduard_Munteanu: turner's relatively recent roundup paper is good.  [23:51:31]
<sw17ch> Where's the array fusion paper?
<vixey> Eduard_Munteanu, Simple Typed Lambda Calculus is a good start
<Axman6> Goober: can i ask again, and get an answer this time, have you ever written any haskell?  [23:51:32]
<Eduard_Munteanu> Philippa, I participated in this year's GSoC :)  [23:51:34]
<sw17ch> i mean, recycling  [23:51:35]
<Wrong> alar yes  [23:51:39]
<daf> Eduard_Munteanu: http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf, perhaps
<Goober> anyways, this is still fundamentally different from using Haskell's typesystem as a macro assembler  [23:51:45]
<Eduard_Munteanu> quicksilver, vixey, daf: thanks.  [23:51:53]
<Goober> which does not even imply any GC  [23:51:57]
<Goober> or imply anything at all  [23:52:07]
<quicksilver> Eduard_Munteanu: it is the footnote to that paragraph you linked to me  [23:52:20]
<Philippa> Eduard_Munteanu: yeah, I didn't really in SoC itself though I still got sent a t-shirt
<Axman6> Goober: i think you want haskell to do something no one else wants it to  [23:52:25]
<vixey> Eduard_Munteanu, Lectures on Curry-Howard Isomorphism covers STLC (and other things)  [23:52:26]
<salty-horse> quicksilver, here's a better phrasing of my qusetion: http://hpaste.org/12748  [23:52:28]
<Goober> the GC exists only at Compile time  [23:52:32]
* alar wonders why some authors put default implementations in separate module  [23:52:50]
<Eduard_Munteanu> quicksilver, oh, I see.  [23:52:53]
<quicksilver> salty-horse: yes.  [23:52:54]
<Philippa> (I didn't end up mentoring this year, that is: still participated in the selection beforehand)  [23:52:55]
<quicksilver> salty-horse: (->) is right associative  [23:53:01]
<lilac> Goober: if what you want is to use haskell to write a program which generates assember code for another program, that's actually really easy
                                                                                                                                                [23:53:16]
<salty-horse> quicksilver, were the steps I made logical?  [23:53:24]
<quicksilver> salty-horse: so (a -> b -> c) -> (a -> b -> c) is (a -> b -> c) -> a -> b -> c  [23:53:27]
<Eduard_Munteanu> Philippa, nice. I worked for Linux Foundation on the kmemtrace project. Got a t-shirt too.  [23:53:30]
<quicksilver> salty-horse: yes, they were.  [23:53:33]
<sw17ch> harpy!  [23:53:37]
<edwardk> alar: depends on the library but there are a number of reasons, sometimes you don't want to have big instances dragged in with the classes just
          in case th user has another instance in mind  [23:53:41]
<quicksilver> salty-horse: even if you didn't fully understand why they were logical, they were ;)  [23:53:44]
<quicksilver> salty-horse: you can remove parens around (->) at the right hand end but not the left hand end.  [23:53:59]
<quicksilver> because -> associates to the right.  [23:54:07]
<edwardk> alar: keep in mind that a lot of typeclasses would admit multiple implementations, when you define a Monoid you are forcing the user into your
          worldview about which Monoid  [23:54:11]
<Philippa> lilac: not only is it, but similar approaches have been used for hardware design with Haskell :-)  [23:54:20]
<Axman6> Goober: am i going to get an answer or not?  [23:54:35]
<Goober> quicksilver: What does this paper have to do with {-# RULES #-} ??  [23:54:40]
<salty-horse> quicksilver, if I remove parentheses from "left" areas of the signature, then haskell will make different bindings to the pattern I
              supplied, right? that's why it's safe to remove the right-side parens? (sorry if I got the terms wrong)  [23:54:44]
<edwardk> so, for instance there is a monad instance for (->)e. should it be in scope whenevr you bring in the Reader monad class?  [23:55:07]
<alar> edwark: default implementation must be consistent anyway, regardless of different instances  [23:55:08]
<BeelsebobWork> @bot  [23:55:09]
<lunabot>  :)  [23:55:10]
<BeelsebobWork> oh, has lambdabot died?  [23:55:16]
<Goober> I thought you were sending something about ghc optimizations as a lib  [23:55:19]
<edwardk> beelsebob: apparently  [23:55:26]
<quicksilver> Goober: they implemented those clever tricks using RULES  [23:55:36]
<Goober> quicksilver: Ah  [23:55:44]
<quicksilver> Goober: which effectively taught GHC a whole new kind of optimisation.  [23:55:46]
<quicksilver> Goober: without needing to change the compiler source at all.  [23:55:52]
<Goober> neat  [23:55:59]
<quicksilver> salty-horse: yes, removing parens from the left changes the function to something else entirely.  [23:56:29]
<Goober> axman6: no  [23:56:31]
<Goober> I don't know how to respond to you, you keep telling me I'm not using haskell for what it should be or something  [23:56:52]
<orbitz> Goober: I think you would benefit from writing a few projects in Haskell  [23:57:09]
<Axman6> Goober: my question is simple, have you written any haskell before, that's it  [23:57:15]
<salty-horse> quicksilver, ok. is this "effect" also due to currying? or is it simply due to ->'s precedence?  [23:57:21]
<quicksilver> salty-horse: it is simply due to ->'s precedence.  [23:57:37]
<Goober> I'm a haskell newb  [23:57:40]
<quicksilver> salty-horse: it's just a convention of how we write stuff.  [23:57:49]
<sw17ch> Goober: sos lines > 0?  [23:57:51]
<quicksilver> salty-horse: we could choose to right all the parens, all the time  [23:57:56]
* edwardk was so tempted to come in here and ask what a comonad was.  [23:57:57]
<quicksilver> salty-horse: but that would be a lot of parens.  [23:58:01]
<lilac> salty-horse: (->) is right-associative. that makes it easier to write the types of curried functions, but is an arbitrary choice other than that,
        i think.  [23:58:04]
<Goober> no, more like: I haven't crossed over into understanding yet how to write PROGRAMS in haskell  [23:58:08]
<Goober> which, I think, practical haskell book touches on.  [23:58:35]
<sw17ch> Goober: map (+1) [1,2i400] <-- this means nothign to you then?  [23:58:37]
<Axman6> Goober: well, learn before critisising  [23:58:47]
<Goober> means something, sw17ch  [23:58:49]
<lilac> Goober: do you think it would help you to understand how haskell compiles to asm?  [23:58:52]
<orbitz> sw17ch: the answer is pi!  [23:58:59]
<Goober> that's an easy one
<Goober> i learned map in learnyouahaskell  [23:59:07]
<Axman6> good  [23:59:12]
<Goober> however, many other languages have it  [23:59:15]
<sw17ch> [ (x,y)  [23:59:26]
<salty-horse> quicksilver, you mean like (a->(b->(c->(d->e))))? which better emphasizes the "all functions have only one parameter" view?  [23:59:30]
<Axman6> what about foldl (+) [1i100]?  [23:59:31]
<Goober> foldl is easy.  [23:59:35]
<orbitz> Goober: it might be good to forget abotu ASM and C for long enough to learn how to write things in haskell, then you can go back to determining
         how it translates to ASM  [23:59:38]
<sw17ch> [ (x,y) | x <- [1i], y <- [1..x], gcd x y == 1]  [23:59:41]
<sw17ch> how about that  [23:59:44]

[‘Áù 12‘ÔÂ  6 2008]
<quicksilver> salty-horse: yes.  [00:00:01]
<edwardk> eri what did i miss that Goober did/said to get the fifth degree?
<sw17ch> (i'm just trying to get a rough understanding of what you know already)
<saml> > [ (x,y) | x <- [1i], y <- [1..x], gcd x y == 1]  [00:00:03]
<Wrong> Axman6: doesn't typecheck  [00:00:12]
<Axman6> heh, indeed.  [00:00:17]
<Wrong> :)  [00:00:24]
<Axman6> foldl (+) 0 [1i100]*  [00:00:27]
<salty-horse> quicksilver, lilac. thanks a lot for helping me understand this!  [00:00:43]
<saml> > foldl (+) 0 [1i100]  [00:00:46]
<Axman6> gahh, we need lambdabot back!  [00:00:58]
<BeelsebobWork> who broke her?  [00:01:07]
<quicksilver> , foldl (+) 0 [1i100]  [00:01:08]
<saml> ok i'll pretend as a lambdabot  [00:01:10]
<lunabot>  5050  [00:01:12]
* saml opens ghci and readys to copy and paste  [00:01:27]
<Goober> sw17ch: i do understand that one  [00:01:51]
<Axman6> BeelsebobWork: no idea :\  [00:01:52]
<quicksilver> , "that won't be" ++ " " ++ "neccessary, saml"  [00:02:00]
<lunabot>  "that won't be neccessary, saml"  [00:02:02]
<Goober> although I find the defining of the gcd function inside the list to be odd  [00:02:08]
<saml> lunabot, poser!  [00:02:15]
<sw17ch> Goober: it's not being defined inside the list, just used  [00:02:23]
<quicksilver> Goober: == isn't a definition, it's a equality  [00:02:28]
<orbitz> Goober: he isn't  [00:02:30]
<BeelsebobWork> saml: that's not good enough, you should be working with pencil and paper to truely emulate a bot  [00:02:33]
<quicksilver> Goober: one "=" for defn, two "==" for comparison.  [00:02:37]
<orbitz> Goober: gcd is part of Prelude  [00:02:39]
<alar> function inside of list is memoization for free  [00:02:51]
<sw17ch> Goober: that produces a list of all relatively prime numbers  [00:02:59]
<Axman6> , take 50 [ (x,y) | x <- [1i], y <- [1..x], gcd x y == 1]  [00:03:21]
<lunabot>  [(1,1),(2,1),(3,1),(3,2),(4,1),(4,3),(5,1),(5,2),(5,3),(5,4),(6,1),(6,5),s  [00:03:23]
<dons> hey all  [00:03:37]
<sw17ch> oh good, dons is here :)  [00:03:44]
<drdozer> hi all  [00:04:11]
*** ToRA|MSR_ (n=t-trallw@nat/microsoft/x-a2f17748f416723a) is now known as ToRA|MSR  [00:04:16]
<alar> greetings  [00:04:19]
<dons> sw17ch: wassup?  [00:04:28]
<Axman6> Goober: direct all Haskell m> ASM questions to dons, and you may be amazed  [00:04:32]
<dons> i've got about 5 mins.  [00:04:33]
<dons> oh. asm time!  [00:04:38]
<drdozer> is there an uncurry I could use for (a -> b -> c -> d) -> ((a, b), c) -> d  [00:04:41]
<dons> i think i wrote about some of ghc's code gen tricks in RWH, and on the blog.  [00:05:00]
<sw17ch> dons: the last 45 minutes of conversation are best handled by you :)  [00:05:04]
<dons> there's also ghc-core, a good tool for reading the core/assembly  [00:05:08]
<Twey> :t uncurry . (. uncurry)  [00:05:16]
<dons> with syntax highlighting for assembly. i know you all like that.  [00:05:20]
<Goober> What I'm wondering now, Is there a way to get Haskell <-> Asm concordance output?  [00:05:26]
<Twey> :(  [00:05:28]
<dons> yes.  [00:05:29]
<dons> Goober: via the ghc-core program  [00:05:33]
<dons> it's on hackage.haskell.org  [00:05:38]
<Axman6> dons: quick update, us aussies (ivnam and I) won't be getting RWH until at the earliest the 15th :(  [00:05:39]
<Twey> \b is dead again
<Goober> dons: cool  [00:05:42]
<dons> i wrote it to help me optimise the asm / haskell at the same time  [00:05:50]
<Twey> Anyway
<drdozer> :t uncurry . uncurry  [00:05:55]
<dons> Axman6: 15th of Dec?  [00:06:04]
<Twey> drdozer: It's something like uncurry . (. uncurry)
<Axman6> aye
<saml> Twey, (((a, b1) -> c1) -> b -> c) -> (a -> b1 -> c1, b) -> c  [00:06:07]
<Twey> Hm
<dons> Axman6: sounds ok. but gee , brazil already has copies. :/  [00:06:10]
<Axman6> yeah :\  [00:06:17]
<Twey> Rearrange dots 'til you get it right :-P  [00:06:23]
<saml> no command found, :(  [00:06:27]
<orbitz> Brazil has prettier people than .au and pretty peopel get treated better  [00:06:31]
<drdozer> mm - is lambdabot alive? she doesn't seem to be giving feedback about those :t lines  [00:06:39]
<Twey> saml: *laughs*  [00:06:41]
<Axman6> well, it's an online store that i'd never heard of before, so it could just be O'Reilly doesn't like thems  [00:06:43]
<Goober> dons: Does the xlation of Haskell to ASM make sense to you in common reading, in the same way that asm reading of C makes sense to me? Is it
         just practice?
<Twey> @botsnack  [00:06:52]
<lunabot>  :)  [00:06:53]
<Goober> Or does that apply to nobody :P  [00:06:55]
<dons> yes, just took practice.  [00:06:57]
<Twey> Nope, but lunabot is  [00:07:00]
<dons> now it makes sense, and is pretty easy.  [00:07:02]
<Twey> Does lunabot do types?  [00:07:05]
<dons> Goober: using ghc-core was really useful to help learn the code gen strategies  [00:07:14]
<alar> dons: are you the author of native-code backend?  [00:07:24]
<Goober> well that's great  [00:07:25]
<orbitz> dons: would you suggest it to a haskell newbie?  [00:07:40]
<dons> ghc-core? no.  [00:07:54]
<dons> newbies shouldn't need to read asm
<dons> alar, i wrote some of the Cm layer in the current backend  [00:08:01]
<dons> not the new backend  [00:08:02]
<orbitz> Goober: you might want to get soem haskell practice befor eplaying  [00:08:05]
<dons> which is about to land.  [00:08:07]
* Axman6 has ghc-core suggested to him by dons as a newbie  [00:08:18]
<dons> heh  [00:08:23]
<dons> oops  [00:08:24]
<dons> well, it can't hurt.  [00:08:32]
<sw17ch> dons: when is that new codegen going to land?  [00:08:35]
<Axman6> i was rather confused :P  [00:08:37]
<dons> the medicine. it is good for you.  [00:08:38]
<dons> sw17ch: i saw the first commits last week  [00:08:58]
<Goober> orbitz: Maybe I have a convoluted way of learnings
<gwern> hm. how would I find out whether bytestring has read/show instances?
<Axman6> but, each time i look at it, it makes slightly more sense
<Philippa> Axman6: yeah, if you don't understand Haskell itself yet then it's probably too early :-)  [00:09:04]
<Axman6> Philippa: heh, indeed  [00:09:14]
<gwern> :i ByteString  [00:09:27]
<sw17ch> dons: in the git repo? when will there be a release for with it included?
<orbitz> Goober: i hear that a lot form people. I think it often stems for ma lack of patience  [00:09:36]
